# ê³ ì°¨í•¨ìˆ˜(Higher-order function) ì´í•´í•˜ê¸° !! ğŸ™‹â€â™‚ï¸

---

## ê³ ì°¨í•¨ìˆ˜(Higher-order function)ë€ ë¬´ì—‡ì¼ê¹Œìš”? ğŸ¤”

ê³ ì°¨í•¨ìˆ˜(Higher-order function)ë€ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§í•©ë‹ˆë‹¤.

SwiftëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ì§€ì›í•˜ê¸° ë•Œë¬¸ì—, Swiftì—ì„œëŠ” ê³ ì°¨í•¨ìˆ˜ë¥¼ ìì£¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

> SwiftëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°? ğŸ¤”
> SwiftëŠ” ê°ì²´ì§€í–¥ê³¼ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ëª¨ë‘ë¥¼ ì§€ì›í•˜ëŠ” ë©€í‹° íŒ¨ëŸ¬ë‹¤ì„ ì–¸ì–´ì…ë‹ˆë‹¤.
> ë”°ë¼ì„œ Swiftì—ì„œëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ì ìš©í•˜ì—¬ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> ì´ëŠ” ì½”ë“œë¥¼ ë”ìš± ë‹¨ìˆœí™”í•˜ê³ , ë” ì•ˆì „í•˜ê²Œ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.
> 
> ë‹¤ìŒì€ Swift í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ê°œë…ë“¤ì…ë‹ˆë‹¤ ğŸ™‹â€â™‚ï¸
> 
> 1ï¸âƒ£ **ì¼ê¸‰ í•¨ìˆ˜(First-Class Functions)**
> - **Swiftì—ì„œëŠ” í•¨ìˆ˜ë¥¼ ì¼ê¸‰ ê°ì²´ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤. ì´ëŠ” í•¨ìˆ˜ë¥¼ ë‹¤ë¥¸ í•¨ìˆ˜ì— ì¸ìë¡œ ì „ë‹¬í•˜ê±°ë‚˜, í•¨ìˆ˜ì˜ ë°˜í™˜ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ê±°ë‚˜, ë³€ìˆ˜ì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.**
    ì´ë ‡ê²Œ í•˜ë©´ í•¨ìˆ˜ë¥¼ ë‹¤ë¥¸ í•¨ìˆ˜ì— ì ìš©í•˜ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
> 2ï¸âƒ£ **ë¶ˆë³€ì„±(Immutability)**
> - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ìƒíƒœ ë³€ê²½ì„ ìµœì†Œí™”í•˜ë ¤ê³  ë…¸ë ¥í•©ë‹ˆë‹¤.
    Swiftì—ì„œëŠ” `let` í‚¤ì›Œë“œë¥¼ í†µí•´ ë¶ˆë³€ì„±ì„ ì§€ì›í•©ë‹ˆë‹¤.
    ë¶ˆë³€ì„±ì„ ì§€í‚¤ëŠ” ê²ƒì€ ì½”ë“œê°€ ì˜ˆìƒì¹˜ ëª»í•œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³ , ë©€í‹°ìŠ¤ë ˆë”© í™˜ê²½ì—ì„œì˜ ë²„ê·¸ë¥¼ ì¤„ì—¬ì¤ë‹ˆë‹¤.
>
> 3ï¸âƒ£ **ìˆœìˆ˜ í•¨ìˆ˜(Pure Functions)**
> - ê°™ì€ ì…ë ¥ì— ëŒ€í•´ í•­ìƒ ê°™ì€ ì¶œë ¥ì„ ë°˜í™˜í•˜ê³ , ê·¸ ë¶€ì‘ìš©ì´ ì—†ëŠ” í•¨ìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
    Swiftì—ì„œëŠ” ì´ëŸ¬í•œ ìˆœìˆ˜ í•¨ìˆ˜ë¥¼ í†µí•´ ì½”ë“œì˜ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
> 4ï¸âƒ£ **ê³ ì°¨ í•¨ìˆ˜(Higher-Order Functions)**
> - SwiftëŠ” í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.
    ì´ëŸ¬í•œ í•¨ìˆ˜ë¥¼ ê³ ì°¨ í•¨ìˆ˜ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.
    ì˜ˆë¥¼ ë“¤ì–´ `map`, `filter`, `reduce`ì™€ ê°™ì€ í•¨ìˆ˜ëŠ” ëª¨ë‘ ê³ ì°¨ í•¨ìˆ˜ì…ë‹ˆë‹¤.
>
> 5ï¸âƒ£ **íƒ€ì… ì¶”ë¡ (Type Inference) ë° ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œ**
> - Swiftì˜ íƒ€ì… ì‹œìŠ¤í…œì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ìŠ¤íƒ€ì¼ì„ ì§€ì›í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.
    SwiftëŠ” ë³µì¡í•œ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë‹¤ë£¨ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ê°•ë ¥í•œ íƒ€ì… ì¶”ë¡  ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
> 
> ğŸ™Œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ë”°ë¥´ë©´, ì½”ë“œëŠ” ë” ê°„ê²°í•˜ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•˜ë©° í…ŒìŠ¤íŠ¸í•˜ê¸° ì‰¬ì›Œì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> ë˜í•œ, ë³µì¡í•œ ë¬¸ì œë¥¼ ì‘ì€ ë¶€ë¶„ìœ¼ë¡œ ë¶„í•´í•˜ëŠ” ë° ë„ì›€ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> Swiftì—ì„œëŠ” ì´ëŸ¬í•œ íŒ¨ëŸ¬ë‹¤ì„ì„ ì§€ì›í•˜ë¯€ë¡œ, ê°œë°œìë“¤ì€ í•´ë‹¹ íŒ¨ëŸ¬ë‹¤ì„ì„ í™œìš©í•´ ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ ë‹¤ì–‘í•œ ì ‘ê·¼ ë°©ë²•ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### Swiftì˜ ê³ ì°¨í•¨ìˆ˜ ğŸ¤”
Swiftì˜ ê³ ì°¨í•¨ìˆ˜ì—ëŠ” ëŒ€í‘œì ìœ¼ë¡œ `map`, `filter`, `reduce`ê°€ ìˆìŠµë‹ˆë‹¤.

1ï¸âƒ£ **map** : **ë°°ì—´ì˜ ê° ìš”ì†Œì— ëŒ€í•œ ì£¼ì–´ì§„ ë³€í™˜ì„ ìˆ˜í–‰í•œ ê²°ê³¼ë¡œ ìƒˆ ë°°ì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.**
```swift!
let numbers = [1,2,3,4,5]
let squared = numbers.map { $0 * $0 } // [1, 4, 9. 16, 25]
```

2ï¸âƒ£ **reduce** : **ë°°ì—´ì˜ ëª¨ë“  ìš”ì†Œë¥¼ ê²°í•©í•˜ì—¬ ë‹¨ì¼ ê²°ê³¼ë¥¼ ë§Œë“­ë‹ˆë‹¤.**
```swift!
let numbers = [1,2,3,4,5]
let sum = numbers.reduce(0) { $0 + $1 }
```

3ï¸âƒ£ **filter** : **ì£¼ì–´ì§„ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë§Œì„ ê°€ì§„ ìƒˆ ë°°ì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.**
```swift!
let numbers = [1,2,3,4,5]
let evenNumbers = numbers.filter { $0 % 2 == 0 } // [2, 4]
```

ê³ ì°¨í•¨ìˆ˜ëŠ” Swiftì˜ ì»¬ë™ì…˜ íƒ€ì…ê³¼ í•¨ê»˜ ì‚¬ìš©ë˜ì–´ ì½”ë“œë¥¼ ë”ìš± ê°„ê²°í•˜ê³  ì½ê¸° ì‰½ê²Œ ë§Œë“œëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.
ë˜í•œ ì´ë“¤ í•¨ìˆ˜ëŠ” ê°ê°ì˜ ì‘ì ‘ì„ ëª…í™•í•˜ê²Œ ì„¤ëª…í•˜ë¯€ë¡œ ì½”ë“œì˜ ì˜ë„ë¥¼ ì´í•´í•˜ëŠ” ë°ë„ ë„ì›€ì´ ë©ë‹ˆë‹¤.

---

### Swiftì˜ ê³ ì°¨í•¨ìˆ˜ì˜ ìƒê¹€ìƒˆ ğŸ¤”

```swift!
// map
@inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]

// reduce
@inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result

// filter
@inlinable public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]
```

---

### ì§ì ‘ êµ¬í˜„í•´ë³´ê¸°!! ğŸ¥´

```swift!
// myMap
extension Array {
	func myMap<T>(_ transfrom: (Element) -> T) -> [T] {
		var container: [T] = []
		
		for item in self {
			container.append(transfrom(item))
		}
		return container
	}
}

// myFilter
extension Array {
	func myFilter(_ transfrom: (Element) -> Bool) -> Self {
		var container: [Element] = []
		
		for item in self {
			if transfrom(item) {
				container.append(item)
			}
		}
		return container
	}
}


// myReduce
extension Array {
	func myReduce<T>(initialResult: (T), nextPartialResult: (T, Element) -> T) -> T {
		var result = initialResult
		
		for item in self {
			result = nextPartialResult(result, item)
		}
		return result
	}
}
```
