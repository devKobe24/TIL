# 230703 TIL 👨‍🔬

---

## 동시성 프로그래밍(Concurrency Programming) 👨‍🔬</br>
**💡 동시성 프로그래밍은 멀티 스레드 환경에서 여러 가지 작업을 동시에 처리하는 기술을 말합니다.**
컴퓨터는 여러 가지 일을 동시에 처리하곤 합니다.
영화를 틀어놓고 문서를 작성할 수도 있고, 동시게 다른 영화를 다운 받을 수도 있습니다.

---

### 코어와 스레드 👨‍🔬
**1️⃣ 코어**</br>
**💡 코어는 CPU의 핵심으로 CPU에서 실제로 일을 처리하는 아이입니다.**
그러므로 빠르고 효율적인 코어는 성능이 좋은 컴퓨터의 필요조건이라고 할 수 있습니다.
코어가 많다는 것은 작업을 처리할 아이가 많다는 뜻입니다.

코어는 `한 번에 한 가지`일만 처리할 수 있습니다.
따라서 코어가 여러 개라면 여러 개의 일을 동시에 처리할 수 있습니다.
그러나 실제로는 싱글 코어를 가진 컴퓨터라도 음악을 들으며 문서를 작성하는 등 여러 작업을 동시에 처리할 수 있습니다.

컴퓨터가 똑똑하고 빠르다지만 알고보면 사람과 비슷하게 일을 합니다.
예를 들어 바에 바텐더가 1명 있다고 생각해봅시다.
주문이 밀린 바텐더는 피치크러시, 마티니, 진토닉, 모히토 등을 모두 동시에 만들고 있습니다.
하지만 이것은 **한번에 만드는 것처럼 보이는 것이지,** 사실은 일을 짧은 단위로 나누어서 하나씩 번갈아가면서 칵테일을 만드는 것입니다.

각각의 잔들을 칠링하고, 각각의 잔에 알맞은 용량과 정확한 베이스의 술을 넣고, 안에 들어가야 할 과일이나 향신료를 준비하고, 데코를 위한 재료를 준비하고, 쉐이커를 준비하고, 바스푼으로 저어주고,,, 등 실제로 바텐더가 처리하고 있는 일은 결국 **한 번에 한 가지**인것이지요.

물론 바텐더는 여러 칵테일을 동시에 만들고 있습니다.
코어 역시 같은 맥락으로 일을 처리합니다. 다만 그 속도가 매우 빠른 뿐입니다.
코어가 여러 개라는 말은 바텐더가 여러 명인 것과 같습니다.

예시처럼 바텐더가 여러 가지 작업을 시분할로 나누어 번갈아 가며 처리하는 것을 `동시성 프로그래밍`이라고 합니다.

> 🙋‍♂️ 코어가 많으면 무조건 빠르다?
> 
> 꼭 그렇지는 않지만 그럴 가능성이 높습니다. 조금 애매한 답변이지요? 요즘 컴퓨터에서는 보기 드문 문제이긴 하지만 코어가 여러 개라면 어떤 코어가 어떤 일을 할지 분배해야 할텐데요.
> 이를 분배하는 과정에서 약간의 딜레이가 발생하여 싱글 코어보다 작업 속도가 느린 경우가 있을 수 있습니다.
> 사람이 2명이지만 누가 어떤 일을 할지 빠르게 정하지 않으면 한 사람보다 효율이 더 낮을 수 있는 것 처럼 말입니다.
> 두 번째로 소프트웨어 중에 싱글 코어에만 최적화가 된 소프트웨어도 있을 수 있습니다.
> 이 경우에는 아무리 코어의 갯수가 많더라도 결국 하나의 코어에서만 일을 처리하기 때문에 더 빠르다고 할 수는 없지요.

**2️⃣ 스레드**</br>
스레드는 하드웨어에서의 스레드와 소프트웨어에서의 스레드로 구분이 됩니다.
같은 용어이지만 약간의 의미가 다르기 때문입니다.
우리는 **소프트웨어에서의 스레드에 주목해야합니다.**

먼저 하드웨어에서의 스레드는 하이퍼스레딩 기술을 이용하여 하나의 코어로 2가지 작업을 동시에 수행할 수 있도록 하는 **논리적인 '코어'** 라고 할 수 있습니다.
1코어 2스레드라면 실제로 코어는 1개이지만 **코어가 2개인 것처럼** 작업을 처리하게 됩니다.

반면 소프트웨어에서의 스레드는 **💡 논리적인 '스레드'** 로 프로세스(프로그램) 내부에서의 작업 단위가 되는 **가상의 스레드** 입니다.
여기서 스레드는 프로그램의 작업을 처리하는 아이들을 말합니다.
경우에 따라서 스레드는 하나일 수도, 여러 개(멀티 스레드)가 있을 수도 있습니다.
하나의 스레드가 모든 작업을 처리하는 것보다 여러 개의 스레드에 분산 시켜 작업을 처리하는 것이 효율적일 수 있습니다.

이번 포스팅에서 배울 동시성 프로그래밍이란 **소프트웨어에서의 멀티 스레딩**을 이용한 기술입니다.
즉 여러 스레드를 이용하여 여러 작업을 동시에 처리하는 것입니다.
소프트웨어에서의 스레드는 가상으로 만들어진 스레드이기 때문에 물리적인 스레드 갯수와는 상관없이 많은 스레드를 만들 수 있습니다.

---

### 동시성 프로그래밍과 병렬 프로그래밍 👨‍🔬
**1️⃣ 병렬 프로그래밍**</br>
**병렬 프로그래밍은 `여러개의 CPU(코어)가 하나의 작업(Task)을 분담해서` 처리하는 것 입니다.**
만약 아주 큰 영상 혹은 그래픽을 처리해야 한다고 했을 떄 여러개의 CPU가 이미지를 분할하여 담당한다면 조금 더 빠르게 작업을 처리할 수 있습니다.
실제로 많은 연산이 필요한 그래픽 처리나 머신 러닝에서는 이 병렬 프로그래밍이 적극적으로 사용되곤 합니다.

다른 예로 3명의 바텐더가 있는 바에서 모히토 주문이 들어왔을 때, 누군가는 라임을 자르고, 누군가는 민트와 라임을 으깨고, 누군가는 데코를 위한 장식을 준비하는 것을 '동시에' 진행하는 것과 같습니다.
**모히토 만들기라는 하나의 작업(Task)을** 여러 개의 CPU가 분담해서 처리하는 것이지요.

혼자서 순서대로 작업을 처리하는 것보다 더 빠른 효율을 낼 가능성이 높습니다.
<img src = "https://github.com/devKobe24/images/blob/main/%E2%80%8E%E1%84%87%E1%85%A7%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC1.jpeg?raw=true">

그래서 병렬 프로그래밍은 `물리적인 개념`으로 **CPU(코어)가 여러 개 있을 떄에 가능합니다.**
싱글 코어에서는 병렬 프로그래밍을 할 수 없습니다.
왜냐하면 병렬 프로그래밍은 `실제로 동시에` 작업을 처리하는 것이기 때문입니다.

병렬 프로그래밍은 iOS를 개발하면서 직접 구현할 일은 없을 것입니다.
그러니 동시성 프로그래밍과 비교하여 개념만 알아두면 됩니다.
운영체제에서 알아서 처리해주는 영역이기 때문입니다.

**2️⃣ 동시성 프로그래밍**</br>
**동시성 프로그래밍은 하나의 CPU가 여러 작업을 동시에 처리하는 것 입니다.**
동시성 프로그래밍은 병렬 프로그래밍과 달리 싱글 코어에서도 가능한 `논리적인 개념`입니다.
물리적으로는 하나의 작업만 처리하는 환경(코어가 하나)에서 논리적으로 여러 일을 동시에 처리하기 때문입니다.

동시성 프로그래밍은 `여러 개의 스레드를 이용하여 동시에 여러 작업을 처리합니다.`
동시성 프로그래밍은 앞서 설명한 적 있는, 1명의 바텐더가 동시에 3잔의 칵테일을 만드는 것과 같습니다.

실제로는 여러 가지 작업을 나열해두고 하나씩, 그리고 조금씩 번갈아가면서 작업을 처리하는 것인데 그 속도가 매우 빨라서 동시에 작업을 처리하는 것처럼 보여집니다.
아주 빠르게 **Context Switching** 을 하고 있는 것 입니다.

> 📌 직렬성(Serial) 프로그래밍
> 
> 동시성 프로그래밍과 반대되는 개념은 직렬성 프로그래밍(Serial Programming)이라고 할 수 있습니다.
> 동시성 프로그래밍(Concurrency Programming) "다중 스레드"를 활용하지만 직렬설 프로그래밍은 "단 하나의 스레드"에서만 작업을 하는 것입니다.
> 즉, 동시에 작업을 처리하지 못하고, 순서대로 작업을 처리해야합니다.

---

### 병렬/동시성 프로그래밍에 대한 오해 👨‍🔬</br>
**1️⃣ 동시성 프로그래밍은 병렬 프로그래밍과 반대되는 개념은 아닙니다.**</br>
**병렬 프로그래밍은 `다중 코어`를, 동시성 프로그래밍은 `다중 스레드`를 활용하는 것이며 이 둘은 동시에 일어날 수도 있습니다. 소프트웨어를 개발하는데에 있어서는 동시성 프로그래밍과 병렬 프로그래밍의 개념만 이해하고 있어도 됩니다.**
어떤 코어에서, 어떤 스레드에서 작업을 처리해줄지에 대해서는 직접 구현할 일이 없고 시스템이 알아서 처리해줄 것이기 때문입니다.

**2️⃣ 여러 가지 일을 여러 개의 코어에서 담당하는 것은 병렬 프로그래밍이 아닙니다.**</br>
정확히는 병렬 프로그래밍일 수도 있고, 아닐 수도 있습니다.
시스템에서 어떻게 일을 처리하게 하는지는 정확히 알 수 없기 때문입니다.
하지만 4가지 일을 4개의 코어가 하나씩 담당해서 한다고 생각했을 때 이것은 사실 병렬 프로그래밍이 아닙니다.
**병렬 프로그래밍은 한 가지 일을 여러 코어가 분담해서 하는 것 입니다.**
이 상황은 각 코어가 일을 하나씩 맡아서 처리하는 상활일 뿐입니다.
별개의 이야기지만 일을 처리하는 내부적인 환경은 단일 스레드 환경일 수도 있고, 다중 스레드 환경일 수도 있습니다.

---

### 동기(Synchronous)와 비동기(Asynchronous)
동시성 프로그래밍을 하는데에 있어 동기(Synchronous)와 비동기(Asynchronous)를 이해하는 것은 매우 중요합니다.
그래야 정확하게 의도대로 코드를 동작시킬 수 있기 때문입니다.

**1️⃣ 동기(Synchronous)**</br>
**💡 동기 프로그래밍은 작업기 끝나기를 기다리는 것입니다.**
예를 들어 A라는 코드 블록을 동기로 처리했다면 A라는 코드의 실행이 완전히 끝나야 다음 코드로 넘어가는 것입니다.

**2️⃣ 비동기(Asynchronous)**</br>
**💡 비동기 프로그래밍은 작업이 끝나기를 기다리지 않고, 다음 코드 블록을 바로 실행시키는 코드입니다.**
A, B라는 작업이 나열되어 있고 A를 비동기 처리해주었을 때 A를 기다리지 않고 바로 B 작업을 시작하게 됩니다.

**💡 동기와 비동기는 이렇게 작업 끝나기를 기다리느냐 않느냐에 대해서 구분되는 개념입니다.**</br>
**이러한 개념의 차이는 `실행 종료 시점을 알 수 있는가`에 대한 차이로 이어집니다.**

동기로 처리되는 작업은 무조건 작업이 동료되길 기다리게 되니 작업이 종료된 후에 할 일을 정해줄 수 있습니다.
하지만 비동기의 경우에는 언제 작업이 종료되는지를 알 수 없습니다.
작업이 끝나기를 기다리지 않기 때문입니다.

> 📌 비동기 프로그래밍과 콜백 함수
> 
> 비동기 프로그래밍에서 작업이 언제 종료될지를 직접적으로 알 수는 없지만, 
> 작업이 완료되었을 때 실행되는 콜백 함수 같은 메커니즘을 사용해 작업의 완료를 감지하고 처리할 수 있습니다.

얼핏 들으면 처음에는 `동시성`이라는 말과 `비동기`라는 말이 헷갈릴 수도 있습니다. 하지만 이는 `완전히 다른 이야기입니다.`

- **"동시성" :** Serial이냐, Concurrent인가는 스레드가 단일 스레드인가, 다중 스레드인가의 구분
- **"동기 / 비동기 :"** 스레드의 수와는 무관하게 작업이 끝나기를 기다리냐, 기다리지 않느냐의 구분

Serial(직렬) 환경에서 비동기(Asynchronous)로 처리할 수도 있고, 동기(Sychronous)로 처리할 수 있습니다.
그리고 Concurrent(동시) 환경에서 동기(Synchronous)로 처리할 수 있고, 비동기(Asynchronous)로도 처리할 수 있습니다.
따라서 이 둘은 완전히 다른 문제로 바라 보아야합니다.

---

### 동시성 프로그래밍(Concurrency Programming)이 필요한 이유? 👨‍🔬</br>
**1️⃣ 효율적으로 동작하는 소프트웨어**</br>
**💡동시성 프로그래밍은 여러 개의 스레드를 이용해서 일을 나누어 효율적인 작업 처리를 할 수 있게 합니다.**
동시성 프로그래밍을 하지 않으면 모든 일을 하나의 스레드에서 담당하게 됩니다.
동시성 프로그래밍을 하게 되면 소프트웨어가 더 쾌적하고 효율적으로 동작할 수 있게 해줍니다.
성능을 개선하여 최적화로 이어지기도 합니다.

**2️⃣ 사용성, 반응성이 좋은 소프트웨어**</br>
**💡 효율적으로 동작한다는 이점은 결국 `사용성, 반응성`이 좋아진다로 귀별됩니다.**</br>
우리는 동시성 프로그래밍을 통해 `사용자들에게 보다 나은 사용성을 제공할 수 있습니다.`
예를 들어 어떤 파일을 다운받을 때 사용자가 아무런 동작을 할 수 없다면 어떨까요?
또 서버로부터 정보를 받아오는 동안 앱이 동작하지 않는다면 어떨까요?
반대로 최적화가 잘 되어있는 앱을 사용하면 쾌적한 느낌을 받게 됩니다.

---

### Swift와 동시성 프로그래밍 👨‍🔬</br>
**💡 Swift로 동시성 프로그래밍을 구현하는 방법에는 `GCD, Operation, async/await`가 있습니다.**</br>

**1️⃣ GCD는 이 셋 중에 가장 먼저 등장했던 것이면서 Operation의 근간이 되는 API입니다.**</br>

**2️⃣ Operation은 GCD를 기반으로 만들어졌으며 세부적인 기능들이 추가된 API입니다.**</br>

**3️⃣ async / await는 Swift 5.5 버전에서 등장하게 된 셋 중에서는 가장 최신의 것입니다. Swift에 등장한 것이 최신이라는 말이지, 사실은 다른 언어에 있는 문법을 Swift화해서 가져온 것입니다.**</br>

---

### 용어 사전 📓
**1️⃣ Context Switching**</br>
**💡 컴퓨터 과학에서 "컨텍스트 스위칭(Context Switching)"은 운영 체제가 프로세스나 스레드 간에 전환하는 과정을 의미합니다.**
**이것은 중앙 처리 장치(CPU)가 각각의 작업 사이에서 전환할 수 있게 하여, 여러 프로세스가 동시에 실행되는 것처럼 보이게 만드는 기술입니다.**

**👉 "컨텍스트(Context)"는 현재 실행 중인 프로세스의 상태를 의미합니다. 이것은 프로세스가 실행을 재개하는 데 필요한 CPU 레지스터, 프로그램 카운터, 스택 포인터 등의 정보를 포함합니다.**

**👉 "스위칭(Switching)"은 컨텍스트의 저장 및 복원을 의미합니다. 운영 체제는 실행 중인 프로세스를 중단하고, 그 프로세스의 컨텍스트를 메모리에 저장한 다음, 다른 프로세스의 컨텍스트를 메모리에 저장한 다음, 다른 프로세서의 컨덱스트를 메모리에서 복원하고 실행을 재개합니다.**

컨텍스트 스위칭의 과정은 다음과 같습니다.

1. **인터럽트 :** 운영 체제는 타이머 인터럽트, 입출력 인터럽트, 운영 체제 서비스 호출 등 다양한 이유로 프로세스를 중단하고 컨텍스트 스위칭을 시작합니다.
2. **컨텍스트 저장 :** 운영 체제는 현재 실행 중인 프로세스의 컨텍스트를 메모리에 저장합니다. 이는 프로세스의 상태를 나중에 복원하기 위해 필요합니다.
3. **스케줄링 :** 운영 체제는 다음에 실행할 프로세스를 결정합니다. 이는 스케줄러에 의해 수행되며, 이는 우선 순위, 응답 시간, 대기 시간 등 다양한 요인을 고려합니다.
4. **컨텍스트 복원 :** 운영 체제는 선택된 프로세스의 컨텍스트를 메모리에서 복원합니다. 이 프로세스는 마지막으로 중단되었던 지점부터 실행을 재개합니다.

이렇게 컨텍스트 스위칭을 통해, 운영 체제는 CPU의 효율적인 사용을 가능하게 하고, 여러 프로세스와 스레드를 동시에 실행하는 것처럼 보이게 합니다.
그러나 컨텍스트 스위칭은 오버헤드를 발생시키며, 이로 인해 성능이 감소할 수 있습니다.
따라서 운영 체제는 필요한 만큼의 최소한의 컨텍스트 스위칭만 수행하려고 노력합니다.

---

**2️⃣ Overhead(오버헤드)**
**💡 "오버헤드(Overhead)"는 컴퓨터 과학에서 일반적으로 어떤 작업을 수행하는데 필요한 추가적인 자원이나 시간을 의미합니다.**
**오버헤드는 특정 목적을 달성하기 위해 필요하지 않은, 그러나 그 목적을 달성하는 프로세스의 일부로 발생하는 비용입니다.**

예를 들어, 네트워킹에서 데이터 패킷을 전송할 때, 실제로 전송되는 유용한 정보(페이로드) 외에도 패킷 헤더, 오류 검사 코드, 프로토콜에 필요한 다른 정보들이 포함됩니다.
이러한 추가 정보는 패킷의 전송과 수신을 제어하는 데 필요하지만, 실제로 유용한 데이터의 전송에 직접적으로 기여하지는 않습니다.
이것이 네트워크 오버헤드의 한 예입니다.

컴퓨터 시스템에서, 오버헤드는 다음과 같은 형태로 나타날 수 있습니다.

1. **시간 오버헤드 :** 특정 작업을 수행하는데 필요한 추가적인 시간, 예를 들어, 컴퓨터가 작업을 수행하는 동안 다른 작업을 대기시키는 시간 등이 있습니다.
2. **공간 오버헤드 :** 특정 작업을 수행하는데 필요한 추가적인 저장 공간. 예를 들어, 특정 데이터 구조를 유지하는데 필요한 메모리나 디스크 공간 등이 있습니다.
3. **복잡성 오버헤드 :** 시스템 또는 알고리즘이 복잡해짐으로써 발생하는 비용. 예를 들어, 데이터를 암호화하는데 필요한 추가적인 계산 등이 있습니다.

오버헤드를 최소화하는 것은 시스템 설계 및 프로그래밍에서 중요한 고려 사항입니다.
불필요한 오버헤드가 많을수록 시스템의 성능이 저하되고, 유용한 작업을 수행하는 데 필요한 자원이 소비됩니다.
따라서, 오버헤드를 줄이면서도 시스템의 기능을 유지하는 방법을 찾는 것이 중요합니다.

---

**3️⃣ 데이터 패킷(Packet)과 페이로드(Payload)**</br>
**네트워킹에서 "데이터 패킷"은 정보를 전달하는 기본 단위입니다. 패킷은 헤더와 페이로드로 구성되며, 헤더는 패킷이 어디로 가야 하는지, 어떻게 처리되어야 하는지 등의 메타데이터를 포함하고, 페이로드는 실제로 전달되어야 하는 데이터를 포함합니다.**</br>

**👉 데이터 패킷(Packet)**</br>
**데이터 패킷은 디지털 네트워크를 통해 전송되는 데이터의 형식화된 블록입니다.**
패킷은 네트워크를 통해 효육적으로 전송되기 위해, 헤더, 페이로드, 그리고 때로는 트레일러(패킷의 끝을 나타내는 부분)로 구성됩니다.
패킷의 헤더는 보통 목적지 주소, 출발지 주소, 패킷의 길이 등의 정보를 포함하며, 라우팅 정보나 오류 검사를 위한 데이터도 포함될 수 있습니다.

**👉 페이로드(Payload)**</br>
**페이로드는 패킷에서 실제로 전송되어야 하는 정보나 데이터를 의미합니다.**
패킷의 헤더나 트레일러와 달리 페이로드는 전송하는 메시지나 파일 등의 실질적인 내용을 담고 있습니다.
이러한 정보는 전송 과정에서 암호화될 수도 있고, 더 작은 단위로 나눠질 수도 있습니다.

예를 들어, 이메일을 전송할 때, 전체 이메일 메시지는 페이로드가 될 수 있고, 이메일의 수신자, 발신자 정보, 메시지가 어떻게 전송되어야 하는지 등의 정보는 헤더에 포함됩니다.

이렇게 헤더와 페이로드를 합쳐서 패킷을 구성하고, 이 패킷을 인터넷을 통해 전송하게 됩니다.
수신 측에서는 헤더 정보를 읽어 이메일을 적절하게 처리하고, 페이로드를 읽어 실제 이메일 메시지를 사용자에게 보여줍니다.

패킷과 페이로드의 이러한 개념은 컴퓨터 네트워크에서 정보를 효율적으로 전송하고 관리하는 데 필수적입니다.

---

**4️⃣ 메타데이터(Metadata)**</br>
**💡 "메타데이터(Metadata)"는 일반적으로 "데이터에 대한 데이터"라고 설명됩니다.**
**메타데이터는 다른 데이터의 세부사항, 특성, 위치, 관련성 등에 대한 정보를 제공하여 해당 데이터를 이해하고, 분류하고, 사용하는 데 도움을 주는 정보입니다.**

메타데이터의 사용 사례는 광범위하며, 데이터를 이해하고 조직하는 데 있어 중요한 역할을 합니다.
예를 들어, 디지털 사진의 메타데이터는 촬영 날짜, 시간, 카메라 설정, 위치 등을 포함할 수 있습니다.
이러한 정보는 사진 자체의 픽셀 데이터와는 별개로 저장되며, 사진을 분류하거나 검색하는 데 사용될 수 있습니다.

컴퓨터 과학에서, 메타데이터는 파일 시스템, 데이터베이스, 웹 페이지 등 다양한 곳에서 사용됩니다.

**1. 파일 시스템 :** 파일에 대한 메타데이터는 파일 이름, 생성 일시, 수정 일시, 파일 크기 등을 포함할 수 있습니다. 이러한 정보는 파일을 관리하고 검색하는 데 도움이 됩니다.
**2. 데이터베이스 :** 데이터베이스의 메타데이터는 테이블 구조, 사용된 데이터 타입, 관계, 제약 조건 등에 대한 정보를 포함할 수 있습니다. 이러한 정보는 데이터베이스를 설계하고, 질의를 구성하고, 데이터를 이해하는 데 도움이 됩니다.
**3. 웹 페이지 :** 웹 페이지의 메타데이터는 페이지의 제목, 설명, 키워드, 저자 등에 대한 정보를 포함할 수 있으며, 이는 검색 엔진이 웹 페이즈를 인덱싱하고 검색 결과를 구성하는 데 사용됩니다.

메타데이터는 데이터에 대한 이해를 깊게 하고, 효과적인 검색 및 조직을 가능하게 하며, 데이터의 의미와 관계를 캡처하고 정의하는 데 중요한 역할을 합니다.
하지만 메타데이터 관리는 주의가 필요하며, 메타데이터가 정확하고 일관성 있어야 합니다.
부정확한 메타데이터는 오해를 일으키고, 정보 검색 및 사용을 방해할 수 있습니다.

---

**5️⃣ 콜백 함수**</br>
**💡 비동기 작업이 종료되면 호출되는 함수입니다. 이 함수는 비동기 작업의 결과를 인자로 받아 사용할 수 있습니다.**

---
