# Section I: Getting Started with Concurrency. 👀</br>

---

## Section 2: GCD vs Operations 👀</br>

앱을 동시성으로 만들 때 사용할 두 가지 API가 있습니다.
일반적으로 **GCD**라고 하는 **Grand Central Dispatch**와 **Operation**입니다.

이들은 경쟁 기술도 아니고 배타적으로 선택해야 하는 것도 아닙니다.
실제고 Operations는 GCD 위에 구축됩니다!

### Grand Central Dispatch 🤔</br>

GCD는 C의 **libdispatch** 라이브러리를 Apple이 구현한 것입니다.
이 라이브러리의 목적은 리소스 가용성에 따라 병렬로 실행할 수 있는 **작업(메서드 또는 클로저)** 을 
큐에 대기시킨 다음 사용 가능한 프로세서 코어에서 작업을 실행하는 것입니다.

> 📌 참고 : Objective-C 에서 사용된 이름이었기 때문에</br>
> Apple의 문서에서는 클로저 대신 블록을 언급하는 경우가 있습니다.</br>
> 동시성의 맥락에서 상호 교환 가능하다고 생각할 수 있습니다.</br>

GCD는 구현에 스레드를 사용하지만 개발자는 스레드를 직접 관리할 필요가 없습니다.
기존 스레드를 생성하려면 수백 개의 명령어가 필요한 반면,
GCD의 작업은 대기열에 넣기 매우 가볍기 때문에 Apple은 2009년 GCD에 대한 기술 요약에서 구현에 15개의 명령어만 필요하다고 언급했습니다.

GCD가 관리하는 모든 작업은 GCD 관리 선입선출(FIFO) 대기열(Queue)에 배치됩니다.
대기열에 제출하는 각 작업은 시스템에서 완전히 관리되는 스레드 풀에 대해 실행됩니다.

> 📌 참고 : 작업이 실행될 스레드에 대한 보장은 없습니다.</br>

### 동기 및 비동기 작업(Synchronous and asynchronous tasks) 🤔</br>

대기열에 배치된 작업은 동기 또는 비동기로 실행될 수 있습니다.
작업을 동기적으로 실행하는 경우 앱은 실행이 완료될 때까지 현재 실행 루프를 대기하고 차단한 후 다음 작업으로 이동합니다.
또는 비동기적으로 실행되는 작업은 시작되지만 실행을 즉시 앱으로 반환합니다.
이렇게 하면 첫 번째 작업이 실행되는 동안 앱에서 다른 작업을 자유롭게 실행할 수 있습니다.

> 📌 참고 : 대기열은 FIFO(First In, First Out) 기반이지만 제출한 순서대로 작업이 완료된다는 보장은</br>
> 없다는 점을 기억하는 것이 중요합니다.</br>
> FIFO 절차는 작업이 끝날 때가 아니라 시작할 때 적용됩니다.</br>

일반적으로 찾을 수 있고 백그라운드에서 비동기식으로 실행할 수 있는 장기 실행 비 UI 작업을 가져오고 싶을 것입니다.
GCD는 다음과 같이 몇 줄의 코드로 클로저를 통해 이를 매우 간단하게 만듭니다.

```swift!
// Class level variable
let queue = DispatchQueue(label: "com.kobe.worker")

// Somewhere in your function
queue.async {
    // Call slow non-UI methods here
    
    DispatchQueue.main.async {
        // Update the UI here
    }
}
```

3장 "대기열과 스레드"에서 **DispatchQueue**에 대한 모든 것을 배우게 됩니다.
일반적으로 대기열을 만들고, 백그라운드 스레드에서 비동기적으로 실행되도록 작업을 제출하고,
작업이 완료되면 코드를 다시 메인 스레드에 위임하여 UI를 업데이트합니다.

### 직렬 및 동시 대기열(Serial and concurrent queues) 🤔</br>

작업이 제출되는 대기열은 **직렬(serial)** 또는 **동시(concurrent)** 대기열이라는 특징도 있습니다.
직렬 대기열에는 하나의 스레드만 연결되어 있으므로 주어진 시간에 하나의 작업만 실행항 수 있습니다.
반면 동시 대기열은 시스템에 리소스가 있는 만큼 많은 스레드를 활용할 수 있습니다.
스레드는 동시 대기열에서 필요에 따라 생성 및 해제됩니다.

> 📌 참고 : iOS에 동시 대기열을 사용하겠다고 말할 수는 있지만, 한 번에 두 개 이상의 작업이</br>
> 실행된다는 보장은 없다는 점을 기억하세요. iOS 디바이스가 완전이 정체되어 앱이 리소스를</br>
> 놓고 경쟁하는 경우 하나의 작업만 실행할 수 있을 수 있습니다</br>

### 비동기는 동시를 의미하지 않습니다(Asynchronous doesn't mean concurrent) 🤔</br>

처음에는 그 차이가 미묘해 보이지만, 작업이 비동기식이라고 해서 동시에 실행된다는 의미는 아닙니다.
실제로 비동기 작업을 직렬 대기열 또는 동시 대기열에 제출할 수 있습니다.
동기식인지 비동기식인지는 단순히 작업을 실행 중인 대기열이 다음 작업을 생성하기 전에 작업이 완료될 때까지
기다려야 하는지 여부를 식별합니다.

반면에 직렬(serial)과 동시(concurrent) 분류는 대기열에 사용할 수 있는 스레드가 단일 스레드인지 또는 여러 스레드인지를 식별합니다. 생각해 보면, 
세 개의 비동기 작업을 직렬 대기열에 제출하는 것은 사용 가능한 스레드가 하나뿐이므로 각 작업이 완전히 완료되어야 다음 작업이 시작될 수 있음을 의미합니다.

즉, 작업이 동기적이거나 그렇지 않은 경우 작업의 소스를 알 수 있습니다.
직렬적이거나 동시적이라는 것은 작업의 목적지를 나타냅니다.

### Operations 🤔</br>

GCD는 백그라운드에서 한 번만 실행해야 하는 일반적인 작업에 유용합니다.
이미지 편집 작업과 같이 재사용이 가능한 기능을 구축할 때는 해당 기능을 클래스로 캡슐화하고 싶을 것입니다.
**Operation**을 서브클래싱하면 이러한 목표를 달성할 수 있습니다!

### Operation subclassing 🤔</br>

**Operation**은 GCD에서 작업 종료를 **DispatchQueue**에 제출하는 것과 마찬가지로 **OperationQueue**에 제출할 수 있는 완전한 기능의 클래스입니다.
클래스에 변수를 포함할 수 있으므로 특정 시점에 작업이 어떤 상태인지 알 수 있습니다.

Opertion은 다음 상태 중 하나로 존재할 수 있습니다.

- **isReady**
- **isExcuting**
- **isCancelled**
- **isFinished**

GCD와 달리 Opertaion은 기본적으로 동기적으로 실행되며, 비동기적으로 실행하려면
더 많은 작업이 필요합니다.
Operation을 직접 실행할 수도 있지만, 동기적 특성으로 인해 좋은 아이디어는 거의 없습니다.
UI 성능에 영향을 미치지 않도록 Operation을 **OperationQueue**에 제출하여 메인 스레드에서 벗어나는 것이 좋습니다.

### Bonus features 🤔</br>

더 있습니다! Operation을 사용하면 작업 취소, 작업 상태 보고, 
비동기 작업을 오퍼레이션으로 래핑하고 다양한 작업 간의 종속성을 지정하는 등의 
일반적인 요구 사항을 처리할 수 있으므로 작업을 더욱 효과적으로 제어할 수 있습니다.

### BlockOperation 🤔</br>

때때로 operation을 많이 사용하는 앱에서 작업하고 있지만 
더 간단한 GCD와 같은 클로저가 필요하다는 것을 알게 됩니다.
**DispatchQueue**도 생성하지 않으려면 대신 **BlockOperation** 클래스를 활용할 수 있습니다.

**BlockOperation**은 **Operation**을 하위 클래스로 분류하고 
기본 글로벌 큐에서 하나 이상의 클로저의 동시 실행을 관리합니다.
그러나 실제 **Operation** 하위 클래스가 되면 작업의 다른 모든 기능을 활용할 수 있습니다.

> 📌 참고 : 블록 작업은 동시에 실행됩니다.</br>
> 직렬로 실행해야 하는 경우 대신 디스패치 대기열을 설정해야 합니다.</br>

### 어느 것을 사용해야 할까요?(Which should you use?) 🤔</br>

앱에서 GCD를 사용해야 하는지 Operations를 사용해야 하는지에 대한 명확한 지침은 없습니다.
실행하고 잊어버리기만 하면 되는 간단한 작업에는 GCD를 사용하는 것이 더 간편합니다.
작업을 추적하거나 취소할 수 있는 기능을 유지해야 하는 경우네는 Operation이 훨씬 더 많은 기능을 제공합니다.

실행해야 하는 메서드나 코드 덩어리로만 작업하는 경우 GCD가 적합한 선택입니다.
데이터와 기능을 캡슐화해야 하는 객체로 작업하는 경우 Operations를 활용할 가능성이 더 높습니다.
일부 개발자는 Operations가 GCD를 기반으로 구축되었기 때문에 항상 사용해야 한다고 극단적으로 말하기도 하는데,
Apple의 지침에 따르면 항상 제공되는 가장 높은 수준의 추상화를 사용하라고 되어 있습니다.

하루가 끝나면 당시에 가장 적합하고 프로젝트 또는 특정 사용 사례의 장기적 지속 가능성을 최대화하는 기술을 사용해야 합니다.

다음 장에서는 Grand Central Dispatch의 작동 방식에 대해 자세히 알아보고,
스레드와 대기열의 차이점에 대해 알아보고, 앱에서 동시성을 구현할 때 발생할 수 있는 몇 가지 복잡성을 식별합니다.

---

### 용어 사전 📚
1️⃣ 가용성</br>

**가용성은 시스템, 서비스, 애플리케이션 또는 리소스가 필요한 시간 동안 신뢰할 수 있게 작동 및 이용 가능한 상태를 유지하는 정도를 나타내는 개념입니다.**
가용성은 일반적으로 시스템이 사용 가능한 시간 비율로 표현되며, 보통 백분율로 표기됩니다.

가용성은 주로 서버, 네트워크, 데이터베이스 등과 같은 IT 시스템과 서비스에 적용되는 개념입니다.
시스템이 가용성이 높다는 것은 사용자가 필요할 때 시스템에 접근하고 사용할 수 있는 확률이 높다는 것을 의미합니다.
예를 들어, 99.9%의 가용성은 일년에 약 8시간 45분 동안 시스템이 다운되거나 접근 할 수 없는 상태일 수 있음을 의미합니다.

가용성은 일반적으로 다음과 같은 요소들에 의해 영향을 받을 수 있습니다.

- 시스템 또는 서비스의 설계와 구현 품질
- 하드웨어 및 소프트웨어의 신뢰성
- 네트워크 인프라의 안정성
- 데이터 백업 및 복구 정책과 절차
- 장애 조치 계획과 대응 능력
- 서비스 수준 계약(SLA)에 따른 서비스 제공 보증

가용성은 중요한 요소로 간주되며, 비즈니스 및 기술적인 측면에서 고려되어야 합니다.
가용성을 향상시키기 위해서는 시스템 설계 시 고가용성을 고려하고, 백업 및 복구 전략을 수립하며, 
장애 발생 시 빠른 대응 및 복구를 위한 계획을 수립하는 등의 다양한 조치를 취할 수 있습니다.
