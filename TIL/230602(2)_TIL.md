# 객체지향 프로그래밍 패러다임(OOP) 🙌

---

객체지향 프로그래밍 패러다임은 컴퓨터 프로그래밍 패러다임의 한 종류로 객체지향 프로그래밍(OOP, Object-Oriented Programming)이라고도 불립니다.

**객체지향 프로그래밍은 컴퓨터 프로그램을 명렁어의 목록으로 보는 기존의 명령형 프로그래밍 패러다임의 시각에서 벗어나 여러 개의 독립된 단위인 객체의 모임으로 파악하고자 하는 시각입니다.**

> 🤔 객체(Object) ?
> 객체지향 프로그래밍(Object-Oriented Programming, OOP)에서 **객체(Object)는 데이터와 그 데이터를 처리하는 방법에 관한 코드를 함께 모아놓은 코드를 함께 모아놓은 소프트웨어 모듈을 의미합니다.**
> 
> 객체는 '클래스'라는 설계도를 기반으로 만들어집니다.
> 클래스는 객체의 특성(속성, 프로퍼티)과 행동(메소드)을 정의합니다.
> 객체는 이 클래스를 기반으로 실체화(Instantiate)된 것으로, 실제 프로그램에서 사용됩니다.
> 
> 예를 들어, '사람'이라는 클래스를 생각해보면, 속성으로는 이름, 나이, 키, 몸무게 등이 있을 수 있고, 행동으로는 걷다, 먹다, 말하다 등이 있을 수 있습니다.
> 
> 그러면 '사람' 클래스를 기반으로 한 '민성'이라는 객체를 만들 수 있고, 이 객체는 '민성'의 이름, 나이, 키, 몸무게와 같은 데이터를 가지며, 걷다, 먹다, 말하다와 같은 행동을 할 수 있게 됩니다.
>

> 🤔 객체지향 프로그래밍의 핵심?
> 객체지향 프로그래밍의 핵심은 코드를 객체로 관리하면서, 실제 세상의 복잡한 문제를 좀 더 쉽게 이해하고, 유연하게 대응할 수 있게 하는 것입니다.
> 
> 객체들 간의 상호작용을 통해 전체 프로그램이 실행되며, 이를 통해 더 복잡한 동작과 프로세스를 모델링 할 수 있습니다.

각각의 객체는 서로 메시지를 주고 받고 데이터를 처리할 수 있습니다.

객체지향 프로그래밍은 프로그램을 유연하고 쉽게 변경할 수 있도록 작성할 수 있어 대규모 소프트웨어 개발에 많이 사용됩니다.

또한 객체만 잘 이해하면 프로그래밍을 더 쉽게 배울 수 있고, 소프트웨어 개발과 유지보수를 간편하게 할 수 있으며, 직관적으로 코드를 분석할 수 있다는 장점이 있습니다.

소프트웨어 공학의 관점에서 소프트웨어의 질을 향상하려면 강한 응집력(Strong Chesion)과 약한 결합력(Weak Coupling)을 지향해야 합니다.

> 🤔 강한 응집력(Strong Chesion)?
> **소프트웨어 공학에서의 '강한 응집력'은 하나의 모듈이나 컴포넌트 내부의 요소들이 밀접하게, 또는 서로 연관되어 작동하는 정도를 말합니다.**
> 즉, 강한 응집력을 가진 모듈은 그 안에서 수행되는 작업들이 서로 관련성이 높으며, 특정한 목표나 기능을 위해 잘 집중되어 있다는 것을 의미합니다.
> 
> 강한 응집력은 소프트웨어 개발에서 중요한 원칙 중 하나로, 유지보수성과 가독성을 높이며, 오류 가능성을 낮추는 데에 기여합니다.
> 또한 재사용성을 향상 시키며, 복잡도를 관리하고, 모듈간의 결합도를 낮추는 데도 도움이 됩니다.
> 
> 객체지향 프로그래밍에서는 클래스나 객체의 응집력을 향상시키는 것이 중요한 설계 원칙이 됩니다.
> 예를 들어, 하나의 클래스는 하나의 명확한 역할이나 책임을 가져야 하며, 그에 관련된 모든 행동과 속성을 포함해야 합니다.
> 이렇게 설계되면 그 클래스는 '강한 응집력'을 가진다고 할 수 있습니다.

> 🤔 약한 커플링(Weak Coupling)?
> **소프트웨어 공학에서 '약한 커플링(Weak Coupling)'은 서로 다른 두 모듈 혹은 시스템이 서로에게 미치는 영향이 최소한이라는 것을 의미합니다**
> 즉, 각 모듈은 자신의 기능을 수행하는 데 있어서 다른 모듈들에 의존하지 않거나, 그 의존성이 매우 낮습니다.
> 
> 약한 결합력을 가진 시스템에서는, 한 모듈이 변경되거나 수정되어도 다른 모듈에 미치는 영향이 최소화됩니다.
> 이는 소프트웨어의 유지보수와 확장성을 향상시키는데 매우 중요한 특성입니다.
> 
> 예를 들어, 객체지향 프로그래밍에서는 '인터페이스'를 통해 약한 결합력을 달성하려고 노력합니다.
> 인터페이스를 사용하면, 하나의 객체가 다른 객체의 구체적인 내부 구현이 아닌 정의된 메소드 세트만을 알고 사용하면 되므로, 각 객체간의 결합력이 약해집니다.
> 
> 이처럼 약한 결합력은 시스템의 유연선을 높이고, 변경에 대한 견고성을 강화하는 데 도움이 됩니다.
> 이는 소프트웨어 생명주기 동안 발생할 수 있는 다양한 변경 사항에 쉽게 대응하고, 필요에 따라 시스템을 확장하거나 수정하기 위해 중요합니다.

**객체지향 프로그래밍은 클래스에 하나의 문제 해결을 위한 데이터와 메서드를 모아놓은 방식으로 응집력을 강화합니다.**

**또, 각 클래스는 독립적이 되도록 디자인해 결합력을 약화합니다.**

그러나 실제 세계의 모습을 프로그램 안에 구현하고자 했던 객체지향 프로그래밍 패러다임이지만, 지나친 프로그램의 객체화 경향 때문에 오히려 실제 세계의 모습을 그대로 반영하기 어렵다는 비판을 받기도 합니다.

객체지향 프로그래밍의 주요 특징으로는 자료 추상화, 상속, 다형성, 동적 바인딩 등이 있습니다.

> 🤔 자료 추상화(Data Abstraction)?
> 객체지향 프로그래밍에서 자료 추상화(Data Abstraction)는 복잡한 시스템을 단순화하는데 중요한 역할을 하는 개념입니다.
> **이는 객체의 복잡한 내부 구현을 숨기고, 사용자에게는 해당 객체의 외부 인터페이스만을 제공하는 것을 의미합니다.**
> 
> 자료 추상화를 통해 객체의 내부 구현이 어떻게 이루어지는지 보다는 무엇을 하는지에 중점을 두게 됩니다.
> 사용자는 객체가 어떤 행동을 하는지 알 수 있지만, 그 행동이 어떻게 구현되어 있는지에 대해서는 알 필요가 없습니다.
> 이런 방식으로, 사용자는 복잡한 내부 구현에 대해 신경 쓸 필요 없이 객체를 사용할 수 있게 됩니다.
> 
> 이러한 추상화는 코드의 복잡성을 줄이고, 객체 간의 독립성을 높여줍니다.
> 이로 인해 코드의 가독성과 유지 보수성이 향상되며, 개발자는 내부 구현을 변경해도 그것이 사용자에게 영향을 미치지 않습니다.
> 이는 소프트웨어 설계의 중요한 원칙 중 하나인 '의존성 역전 원칙'에도 부합하는 개념입니다.

> 🤔 의존성 역전 원칙(Dependency Inversion Principle, DIP)?
> **의존성 역전 원칙(Dependency Inversion Principle, DIP)은 객체지향 설계 원칙 중 하나로, 고수준 모듈이 저수준 모듈에 직접 의존하는 대신, 둘 다 추상화에 의존하도록 설계해야 한다는 원칙입니다.**
> 이 원칙은 소프트웨어 아키텍처의 안정성과 유연성을 증가시키는 데 중요합니다.
> 
> 의존성 역전 원칙(Dependency Inversion Principle, DIP)는 다음과 같은 두 가지 주요 가이드라인을 제공합니다.
> 1. 고수준 모듈은 저수준 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.
> 2. 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다.
> 
> **기본적으로 이 원칙은 "세부 사항이 구조를 결정하게 해서는 안된다"는 아이디어에 기초합니다.**
> 대신, 시스템을 구성하는 모든 모듈은 정의된 추상화를 통해 상호작용해야 합니다.
> 이렇게 하면 각 모듈간의 결합도가 낮아지고, 변화에 대한 유연성이 증가합니다.
>
> 예를 들어, 고수준의 비즈니스 로직을 가진 클래스가 데이터베이스에 직접 접근하는 저수준 클래스에 의존하는 대신, 두 클래스 모두 데이터 접근을 위한 추상 인터페이스에 의존하도록 설계할 수 있습니다.
> 이렇게 하면 데이터베이스 접근 방식이 변경되더라도 비즈니스 로직을 가진 클래스는 영향을 받지 않게 됩니다.
> 이것이 의존성 역성 원칙을 적용한 예입니다.

> 🤔 의존성(Dependency)?
> **소프트웨어 공학에서 의존성(Dependency)은 한 요소가 다른 요소의 기능이나 동작에 의존하는 관계를 의미합니다.**
> 이는 클래스, 모듈, 서비스 등 다양한 소프트웨어 구성요소 사이에서 발생할 수 있습니다.
> 
> 예를 들어, 클래스 A가 클래스 B의 메소드를 사용하면 클래스 A는 클래스 B에 의존하게 됩니다.
> 이 경우, 클래스 B의 메소드에 변경이 생기면 클래스 A에도 영향이 미칠 수 있습니다.
> 즉, 클래스 A의 정상적인 기능 수행은 클래스 B의 특정 메소드에 의존하게 되는 것입니다.
> 
> 이러한 의존성 관리는 소프트웨어 설계에서 매우 중요한 부분입니다.
> 의존성이 높을수록 코드의 재사용성이 떨어지고, 변경에 대한 복잡성이 증가합니다.
> 따라서 가능한 한 의존성을 줄이고, 필요한 의존성은 잘 관리하는 것이 중요합니다.
> 이를 위해 주로 사용되는 방법이 의존성 주입(Dependency Injection), 의존성 역전 원칙(Dependency Inversion Principle)등입니다.

> 🤔 의존성 주입(Dependency Injection)?
> **의존성 주입(Dependency Injection)은 객체지향 프로그래밍에서 의존성 관리를 위한 기법 중 하나로, 한 객체가 다른 객체에 의존할 때 그 의존성을 외부에서 제공해주는 방식을 말합니다.**
> 
> 일반적으로 한 객체가 다른 객체를 사용하기 위해서는 직접 생성하거나, 전역 변수 또는 싱글톤 등을 통해 접근하게 됩니다.
> 하지만 이런 방식은 두 객체를 밀접하게 연결시키므로, 코드의 재사용성을 떨어뜨리고 변경에 취약하게 만듭니다.
> 
> **의존성 주입은 이런 문제를 해결하기 위해, 객체의 생성과 의존성 설정을 객체 자신이 아닌 외부에서 처리하도록 하는 것입니다.**
> 외부에서 의존성을 주입받기 때문에 특정 구현에 강하게 결합되지 않아, 코드의 유연성과 재사용성이 증가합니다.
> 또한 단위 테스트를 수행할 때, 가짜 객체(Mock Object)를 쉽게 주입하여 테스트할 수 있습니다.
> 
> 의존성 주입은 주로 생성자 주입(Constructor Injection), 세터 주입(Setter Injection), 인터페이스 주입(Interface Injection)등의 방식으로 이루어집니다.

> 🤔 다형성(Polymorphism)?
> **객체지향 프로그래밍에서 다형성(Polymorphism)은 하나의 인터페이스, 메서드, 클래스 또는 객체가 다양한 형태로 동작할 수 있는 능력을 가리킵니다.**
> 다형성의 가장 대표적인 예시는 메소드 오버라이딩(Method Overriding)과 메소드 오버로딩(Method Overloading)입니다.
> 
> 1. 메소드 오버라이딩(Method Overriding) : 부모 클래스에서 정의된 자식 클래스에서 재정의되는 경우를 의미합니다. 같은 이름의 메소드가 있지만, 자식 클래스에서 이를 재정의함으로써 다르게 동작하게 하는 것입니다.
> 2. 메소드 오버로딩(Method Overloading) : 같은 이름의 메소드가 다른 매개변수를 갖고 있어서 다르게 동작하는 경우를 의미합니다. 같은 이름의 메소드를 여러 개 정의하지만, 매개변수의 유형이나 수가 다르기 때문에 다양한 방식으로 동작하게 하는 것입니다.
> 
> 이와 같은 다형성의 장점은 다음과 같습니다.
> - 코드의 재사용 : 부모 클래스의 메소드를 재정의(Overriding)하거나 같은 이름의 메소드를 여러 형태로 정의(Overloading)함으로써 코드의 재사용성을 높일 수 있습니다.
> - 유연성 : 다형성은 코드의 유연성을 높이고, 확장성을 갖춘 설계를 가능하게 합니다. 즉, 다형성을 이용하면 새로운 클래스를 추가하거나 기존 클래스를 수정할 때 다른 클래스에 미치는 영향을 최소화할 수 있습니다.
> - 유지보수 : 코드의 유지보수가 쉬워지며, 디버깅도 간편해집니다. 코드의 가독성이 향상되며, 이해하기 쉬워집니다.

> 🤔 동적 바인딩(Dynamic Binding) 또는 늦은 바인딩(Late Binding)?
> **객체지향 프로그래밍에서 동적 바인딩(Dynamic Binding), 또는 늦은 바인딩(Late Binding)은 프로그램이 실행되는 시점에 메소드를 객체와 연결시키는 방법을 의미합니다.**
> 이는 컴파일 타임에 메소드를 결정하지 않고, 런타임에 결정하게 되므로 동적인 특성을 가집니다.
> 
> 이를 통해 다형성을 구현할 수 있는데, 예를 들어 상위 클래스 타입의 참조 변수가 하위 클래스 타입의 객체를 참조할 경우, 해당 참조 변수가 실제로 가리키고 있는 객체의 타입에 따라 호출되는 메소드가 결정됩니다.
> 
> 예를 들어, "Animal"이라는 상위 클래스와 "Dog"과 "Cat"이라는 하위 클래스가 있을 때, "Animal" 타입의 참조 변수가 "Dog" 객체를 참조하면 "Dog" 메소드가 호출되고, "Cat" 객체를 참조하면 "Cat"의 메소드가 호출됩니다.
> 이처럼 프로그램 실행 중에 어떤 메소드가 호출될지 결정하는 것이 동적 바인딩의 특징입니다.
>
> 동적 바인딩은 코드의 유연성을 증가시키고, 코드의 재사용성을 높이는데 큰 역할을 합니다.
> 이로 인해 객체지향 프로그래밍에서 다형성을 실현할 수 있게 됩니다.

객체지향 프로그래밍 패러다임을 차용한 언어에는 스몰토크(Smalltalk), Objective-C, C++, C#, JAVA, Python, Ruby, Swift 등이 있습니다.
