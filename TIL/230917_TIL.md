# Object Oriented Programming(객체 지향 프로그래밍)

**✅ `Object Oriented Programming(OOP)`은 프로그래밍 패러다임 중 하나로, 프로그램 객체들의 모임으로 바라보고 설계하며 구현하는 방식을 말합니다.**
- 객체 지향 프로그래밍은 데이터와 함수(메서드)를 하나의 단위인 **`객체(Object)`** 에 묶어 표현하고, 이러한 객체들 간의 상호작용을 통해 프로그램이 동작하도록 합니다.

---

## iOS 프로그래밍에서의 OOP의 특징과 중요성

1. **클래스와 인스턴스** : Swift 및 Objective-C, 두 주요 iOS 프로그래밍 언어 모두 객체 지향 언어입니다. 클래스를 정의하고 해당 클래스의 인스턴스를 생성하여 사용합니다.


2. **상속** : iOS에서, 여러 UI 컴포넌트와 기능들은 상속을 통해 확장되거나 수정됩니다. 예를 들면, 사용자 정의 `UIViewController`나 `UIViwe`를 생성할 때 상속을 사용합니다.


3. **캡슐화** : iOS 프로그래밍에서 데이터와 메서드를 하나의 클래스 내에 묶어, 외부의 접근으로부터 보호하면서도 해당 기능을 제공합니다. 예를 들면, `private` 나 `public`과 같은 접근 제어자를 사용하여 캡슐화를 구현할 수 있습니다.

4. **다형성** : 하나의 인터페이스나 메서드명으로 다양한 객체들의 기능을 사용할 수 있게 합니다. 예를 들어, 메서드 오버라이드나 프로토콜을 통한 구현으로 다형성을 활용할 수 있습니다.

5. **메시지 전달**: Objective-C의 주요 특징 중 하나는 메시지 기반의 메서드 호출입니다. 이는 객체 간의 상호 작용을 "메시지 전달"로 볼 수 있으며, 이는 객체 지향의 핵심 개념 중 하나입니다.

6. **UIKit 및 Foundation 프레임워크**: iOS 개발에서 사용하는 주요 프레임워크들은 객체 지향 설계 원칙을 기반으로 구축되어 있습니다. 따라서 iOS 개발을 하면서 OOP 개념에 대한 깊은 이해가 필요합니다.</br>

**요약하면, iOS 프로그래밍에서는 OOP 원칙이 깊게 녹아있으며, 앱을 구축하고 개발하는 데 있어 객체 지향 방식의 설계와 구현 방식이 필수적입니다.**

---

## 주니어 iOS 프로그래머 관점에서의 OOP

**✅ 주니어 iOS 프로그래머의 관점에서 OOP(Object Oriented Programming)를 이해하는 것은 iOS 앱 개발의 핵심 적인 부분을 파악하는 것과 같습니다.**</br>

간단하게 풀어서 설명하면 다음과 같습니다.</br>

1. **객체란?**: iOS 앱을 만들 때 화면에 보이는 버튼, 텍스트, 이미지 등 모든 것들은 객체로 볼 수 있습니다. 이 객체들은 특징(속성)과 할 수 있는 일(기능)을 가지고 있습니다. 예를 들면, 버튼은 색깔이나 크기 같은 속성과 눌렀을 때 어떤 동작을 할지 결정하는 기능을 가질 수 있습니다.

2. **클래스**: 객체를 만들기 위한 '틀' 혹은 '정의'입니다. 예를 들어, 핸드폰이라는 클래스를 만들면, 그 안에 '색깔', '크기'. '브랜드'와 같은 속성과 '전화하기', '문자보내기'와 같은 기능을 정의할 수 있습니다.

3. **상속**: 이미 만들어지 클래스의 속성과 기능을 받아와서 조금 수정하거나 추가하여 새로운 클래스를 만드는 것입니다. 예를 들어, '아이폰' 클패스는 '핸드폰' 클래스를 상속받아 특정한 기능이나 속성을 추가할 수 있습니다.

4. **캡슐화**: 객체의 내부 정보나 복잡한 부분을 숨기고, 필요한 부분만 외부에 보여주는 것입니다. 사용자가 앱의 버튼을 누를 때, 그 안의 복잡한 코드를 알 필요 없이 원하는 동작만 수행하게 됩니다.

5. **다형성**: 같은 이름의 기능이지만, 그것을 사용하는 객체에 따라 다르게 동작하는 것을 말합니다. 예를 들어, '음소거' 기능을 가진 핸드폰과 TV는, 같은 이름의 기능이지만 각각 다른 동작을 수행합니다.

**주니어 iOS 프로그래머로서 OOP픞 이해하고 있으면, iOS 앱 개발 프로세스가 훨씬 더 명확해지고, 앱의 구조와 원리를 더 잘 파악할 수 있습니다. iOS의 많은 프레임워크와 라이브러리는 OOP 원칙에 따라 설계 되었기 때문에, OOP를 이해하는 것은 iOS 개발에 있어 기본적인 스킬이라 할 수 있습니다.**

---

# 객체 생활 체조 원칙(Object Calisthenics)

**✅ `객체 생활 체조 원칙(Object Calisthenics)`은 좀 더 깔끔하고 유지보수가 쉬운 코드를 작성하기 위한 연습 방법입니다. 이 원칙은 객체 지향 프로그래밍(OOP)애 중점을 둡니다. 일반적으로 다음과 같은 9가지 원칙으로 구성되어 있습니다.**</br>

---

## 1번 원칙 : 한 메서드에 오직 단일 레벨의 들여쓰기만을 사용합니다.

1. **✅ 한 메서드에 오직 단일 레벨의 들여쓰기만을 사용합니다** : 이 원칙은 메서드의 복잡도를 제한하고 가독성을 높이기 위한 지침입니다. iOS 프로그래밍, 특히 Swift에서, 이 원칙을 적용하는 것은 코드의 구조와 가독성을 개선하는데 큰 도움을 줍니다.</br>

### 🙌1번 원칙의 장점

- 1. **가독성 향상** : 들여쓰기 수준이 많을수록 코드를 읽고 이해하기 어렵습니다. 한 단계의 들여쓰기만 허용하면 메서드는 좀 더 간결하고 명확해집니다.
- 2. **유지보수성 향상** : 들여쓰기 수준이 한 단계만 되면 해당 메서드가 하는 일이 단순해지기 때문에, 나중에 코드를 수정하거나 오류를 찾기가 쉽습니다.
- 3. **재사용성 증가 :** 복잡도가 낮은 메서드는 다른 곳에서 재사용하기가 쉽습니다.</br>

### 🙌 iOS 프로그래밍에서 1번 원칙을 적용하는 방법

- 1. **조기 반환(Early Return)** : `guard` 문을 활용하여 조건을 충족하지 않을 경우 빠르게 반환하도록 합니다. 이렇게 하면 메서드의 본문에 들어가기 전에 필요한 조건들을 먼저 확인하고, 본문에서는 핵심 로직만 남기게 됩니다.</br>

```swift
func updateUserProfile(user: User?) {
    guard let user = user else {
        return
    }
    // ... (update profile logic)
}
```

- 2. **메서드 분리** : 메서드가 여러 작업을 동시에 수행하는 경우, 이를 여러 작은 메서드로 분리하여 각 메서드가 하나의 작업만 수행하도록 만듭니다.</br>

```swift
func updateProfile() {
    validateUserInput()
    saveToDatabase()
}
```

- 3. **피하려는 경우의 수 제거** : `switch` 문이나 `if-else` 구문을 사용할 때 가능한 한 예외적인 경우를 피하고, 메서드의 주된 로직에 집중할 수 있도록 합니다.</br>

### 🙌 1번 원칙 마무리
- 1번 원칙을 따르면, 코드는 그 목적에 집중하게 됩니다. 때문에 개발자는 메서드의 핵심 로직에만 집중할 수 있게 됩니다. 그로 인하여 iOS 앱의 구조와 로직이 더욱 명확해집니다. 더해서 코드의 품직도 향상됩니다.

---

## 2번 원칙 : else 표현을 사용하지 않습니다.

2. **✅ else 표현을 사용하지 않습니다.** : 이 원칙은 코드의 복잡도를 줄이고, 가독성을 향상시키기 위한 지침입니다. iOS 프로그래밍, 특히 Swift에서, 이 원칙은 코드의 결정적인 로직을 명확하게 표현하는 데 중요한 역할을 합니다.</br>

### 🙌 2번 원칙의 장점

- 1. **가독성 향상** : `else` 구문을 사용하지 않으면 코드의 흐름이 선형적이 되어 코드를 읽는 사람이 해당 메서드나 함수의 로직을 빠르게 이해할 수 있습니다.
- 2. **코드의 명확성** : `else` 없이 코드를 작성하면, 각 분기에 대한 조건이 명확해집니다. 이렇게 되면 예상치 못한 부작용이나 오류를 줄일 수 있습니다.
- 3. **유지보수성 향상** : `else` 구문 없이 코드를 구조화하면, 나중에 코드를 수정하거나 확장하기 더 쉬워집니다. 특히 새로운 조건이 추가될 때 이전 조건과의 연관성 없이 독립적으로 추가할 수 있습니다.</br>

### 🙌 iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **조기 반환(Early Return)** : Swift에서는 `guard` 문을 사용하여 조건이 충족되지 않을 경우 빠르게 반환하는 방식으로 `else` 구문의 사용을 줄일 수 있습니다.

```swift
func updateUserProfile(user: User?) {
    guard let user = user else {
        return
    }
    // ... (update profile logic without using else)
}
```

- 2. **다형성 활용** : 객체 지향 프로그래밍에서, [다형성](#다형성)을 활용하여 `else` 또는 `switch` 문을 피할 수 있습니다. 특히 프로토콜과 상속을 사용하여 객체의 특정 행동을 정의하면 `else` 구문 없이도 로직을 분기할 수 있습니다.
- 3. **표현을 명확하게** : 로직을 명확하게 표현하여 `else` 구문 없이도 의도를 분명하게 전달하는 방법을 선택합니다. 예를 들어, 조건을 충족하는 경우만 코드를 실행하도록 하고, 그 외의 경우는 무시하는 방식으로 구현할 수 있습니다.</br>

### 🙌 2번 원칙 마무리

- "else 표현을 사용하지 않는다"는 원칙을 따르면, 코드의 복잡성을 줄이고, 명확성과 가독성을 높일 수 있습니다. 이는 iOS 앱 개발에서 오류를 줄이고, 효율적인 유지보수를 도와주는 중요한 원칙 중 하나입니다.

---

## 3번 원칙 : 모든 원시값과 문자열을 포장합니다.

3. **모든 원시값과 문자열을 포장합니다.** : 이 원칙은 원시 값(예: Int, Double, String등)을 그대로 사용하기보다는 해당 원시 값을 클래스나 구조체로 포장하여 사용하라는 의미입니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙을 적용하는 것은 코드의 구조와 가독성을 개선하는 데 큰 도움을 줍니다.</br>

### 🙌 이 원칙의 장점

- 1. **타입 안전성** : Swift는 강력한 타입 시스템을 가지고 있습니다. 원시 값을 포장하면 해당 값에 특정한 의미나 역할을 부여할 수 있게 되므로, 의도하지 않은 값의 할당이나 연산을 방지할 수 있습니다.
- 2. **캡슐화** : 값에 대한 연산이나 검증 로직을 해당 값을 포장한 클래스나 구조체 내부에 정의할 수 있습니다. 이렇게 되면 해당 로직이 여러 곳에서 중복되는 것을 방지하고, 해당 값에 대한 로직을 한 곳에서 관리할 수 있게 됩니다.
- 3. **의미 있는 추상화** : 원시값을 포장하면 해당 값에 특정한 의미나 역할을 부여할 수 있게 됩니다. 이렇게 하면 코드의 가독성이 높아지고, 해당 값이 어떤 역할을 하는지 쉽게 파악할 수 있습니다.

### 🙌 iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **값 타입 사용** : Swift에서는 구조체(struct)를 사용하여 원시 값들을 포장할 수 있습니다. 이렇게 포장된 값은 메서드나 연산을 통해 그 값을 안전하게 관리하고 조작할 수 있습니다.

```swift
struct Width {
    let value: Double
}

struct Height {
    let value: Double
}
```

- 2. **초기화 및 검증** : 포장된 값은 초기화 시에 필요한 검증을 수행할 수 있습니다. 이렇게 하면 무효한 값이나 예상치 못한 값이 생성되는 것을 방지할 수 있습니다.

- 3. **연산자 오버로딩** : Swift에서는 연산자를 오버로드하여 포장된 값들 간의 연산을 직관적으로 수행할 수 있습니다.</br>

### 🙌 3번 원칙 마무리

- 이 원칙을 따르면, 코드는 그 목적에 집중하게 됩니다. 그로 인해 개발자는 메서드의 핵심 로직에만 집중할 수 있게 됩니다. 이렇게 하면 iOS 앱의 구조와 로직이 더욱 명확해지며, 코드의 품질도 향상됩니다.

---

## 4번 원칙 : 한 줄에 점을 하나만 찍습니다.

4. **한 줄에 점을 하나만 찍습니다.** : 이 원칙은 메서드 체이닝이나 연속적인 프로퍼티 접근을 통한 객체의 접근을 제한하라는 의미입니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙을 적용하는 것은 코드의 가독성과 유지 보수성을 높이는 데 중요합니다.

### 🙌 4번 원칙의 장점

- 1. **가독성 향상** : 한 줄에 여러 점을 찍어 연속적으로 객체나 메서드에 접근하는 것은 해당 코드 라인이 어떤 동작을 하는지 파악하지 어렵게 만듭니다. 한 줄에 점 하나만을 사용하면 코드의 의도가 더 명확해집니다.
- 2. **유지보수성 향상** : 연속적인 메서드 체이닝이나 프로퍼티 접근은 내부 객체의 변경이 외부에 큰 영향을 미칠 수 있습니다. 이 원칙을 따르면, 각 객체의 책임과 역할이 분명해져 객체의 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다.
- 3. **오류 발생 감소** : 한 줄에 여러 점을 찍는 것은 null 참조나 예상치 못한 오류를 초례할 수 있습니다. 이 원칙을 따르면 이러한 오류의 가능성을 줄일 수 있습니다.

### 🙌 iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **명확한 변수 할당** : 연속적인 메서드 체이닝이나 프로퍼티 접근의 결과를 임시 변수에 할당하여, 그 변수를 사용하는 방식으로 코드의 가독성을 높입니다.

```swift
let userAddress = user.profile.address
let zipCode = userAddredd.zipCode
```

- 2. **메서드 분리** : 복잡한 메서드 체이닝이 필요한 경우, 이를 이여러 메서드나 연산에 분리하여 각 메서드나 연산이 하나의 작업만 수행하도록 만듭니다.

```swift
let price = cart.calculateTotalPrice().applyDiscount()
// 위 코드를 아래와 같이 분리
let totalPrice = cart.calculateTotalPrice()
let discountedPrice = totalPrice.applyDiscount()
```

- 3. **객체의 책임 및 역할 명확화** : 객체의 책임과 역할을 명확히 하여, 외부에서 깊은 접근이 필요하지 않도록 설계합니다.

### 🙌 4번 원칙 마무리

- 이 원칙을 따르면, 코드는 그 목적에 집중하게 됩니다. 때문에 개발자는 메서드의 핵심 로직에만 집중할 수 있게 됩니다. 이렇게 하면 iOS 앱의 구조와 로직이 더욱 명확해지며, 코드의 품질도 향상됩니다.

---

## 5번 원칙 : 이름을 축약하지 않습니다.

5. **이름을 축약하지 않습니다.** : 이 원칙은 코드 내의 변수, 함수, 클래스 이름 등을 짧게 축약하지 않고, 그 의미를 명확하게 전달할 수 있는 이름을 사용하라는 지침입니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙의 적용은 코드의 가독성과 유지보수성에 큰 영향을 미칩니다.

### 🙌 5번 원칙의 장점.

- 1. **가독성 향상** : 축약된 이름은 코드를 읽는 사람에게 그 변수나 함수의 실제 의미나 동작을 알려주지 않습니다. 전체 이름을 사용하면 코드를 처음 보는 사람도 쉽게 이해할 수 있습니다.
- 2. **유지보수성 향상** : 명확한 이름을 가진 코드는 추후에 수정이 필요할 때 해당 코드의 동작이나 의미를 빠르게 파악할 수 있기 때문에 유지보수가 쉬워집니다.
- 3. **오해의 위험 감소** : 축약된 이름은 때로는 잘못된 정보나 오해를 초래할 수 있습니다. 이름을 명확하게 표현함으로써 이러한 위험을 줄일 수 있습니다.

### 🙌 iOS 프로그래밍에서 이 원칙을 적용하는 방법.

- 1. **의도를 반영한 명명** : 변수나 함수의 이름에는 그것의 용도나 동작, 반환 값을 명확하게 반영하는 이름을 사용합니다.

```swift
// 나쁜 예시
let u = User()
let d = u.dob()

// 좋은 예시
let user = User()
let dateOfBirth = user.getDateOfBirth()
```

- 2. **기술적인 용어 사용** : 적절한 기술적 용어나 도메인 용어를 사용하여 이름을 지어, 그 의미를 정확하게 전달합니다.

```swift
// 나쁜 예시
let s = "Hello World!"
let r = s.reversed()

// 좋은 예시
let greetingMessage = "Hello, World!"
let reversedMessage = greetingMessage.reverseString()
```

- 3. **불필요한 중복 피하기** : 동일한 정보를 두 번 이상 표현하는 이름은 피합니다. 예를 들어, `UserClass` 대신 `User`를 사용하는 것이 좋습니다.

### 🙌 5번 원칙 마무리.

- 이 원칙을 따르면, 코드 내에서 각 변수나 함수의 역할과 의도가 명확하게 드러납니다. 이로 인해 코드를 읽는 사람이 더 쉽게 이해할 수 있고, 장기적으로 코드의 품질이 높아집니다.

---

## 6번 원칙 : 모든 엔티티를 작게 유지합니다.

6. **모든 엔티티를 작게 유지합니다.** : 이 원칙은 코드의 각 구성 요소(클래스, 구조체, 메서드 등)를 간결하고 명확하게 유지하는 것을 의미합니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙의 적용은 코드의 가독성, 유지 보수성 및 테스트 용이성에 큰 영향을 미칩니다.

### 🙌 6번 원칙의 장점

- 1. **가독성 향상** : 작은 크기의 엔티티는 한눈에 이해하기 쉽습니다. 큰 클래스나 메서드는 그 구조와 로직을 파악하는 데 시간이 걸릴 수 있습니다.

- 2. **유지보수성 향상** : 작은 크기의 엔티티는 수정이 필요할 때 해당 부분의 기능과 책임을 빠르게 파악하고 수정할 수 있습니다.

- 3. **테스트 용이성 증가** : 작은 단위의 엔티티는 단위 테스트하기 쉽습니다. 큰 엔티티는 여러 기능과 책임을 포함하므로 테스트하기 복잡할 수 있습니다.

### iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **SRP(Single Resposibility Principle) 적용** : 한 클래스나 메서드는 하나의 책임만 가져야 합니다. 여러 기능이나 책임을 갖는 클래스는 여러 개의 작은 클래스로 분리할 수 있습니다.

```swift
// 나쁜 예
class UserManager {
    func createUser() {...}
    func deleteUser() {...}
    func displayUser() {...}
}

// 좋은 예
class UserCreationManager {
    func createUser() {...}
}

class UserDeletionManager {
    func deleteUser() {...}
}

class UserDisplayManager {
    func displayUser() {...}
}
```

- 2. **메서드 분리** : 하나의 메서드가 여러 작업을 수행하는 경우, 작은 여러 메서드로 분리하여 각각의 메서드가 하나의 작업만 수행하도록 만듭니다.

```swift
// 나쁜 예
func manageUser(data: Data) {
    validate(data)
    save(data)
    notifyUser()
}

// 좋은 예
func validateUser(data: Data) {...}
func saveUser(data: Data) {...}
func notifyUser() {...}
```

- 3. **의존성 관리** : 필요한 의존성만을 가져야하며, 불필요한 의존성은 제거합니다. 이를 통해 각 엔티티가 자신의 핵심 책임에만 집중할 수 있습니다.

### 🙌 6번 원칙 마무리

- 이 원칙을 따르면 코드의 각 부분이 자신의 책임을 명확하게 수행하게 되고, 전체 애플리케이션의 구조와 로직이 명확해지며, 코드의 품질이 향상됩니다.

---

## 7번 원칙 : 3개 이상의 스위프트 기본 데이터타입(Int, String, Double 등) 프로퍼티를 가진 타입을 구현하지 않는다.

7. **3개 이상의 스위프트 기본 데이터타입(Int, String, Double 등) 프로퍼티를 가진 타입을 구현하지 않습니다** : 이 원칙은 객체의 복잡성을 관리하고 객체 지향적 설계를 촉진하는 데 중점을 둡니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙은 객체의 응집도를 높이고 코드의 명확성 및 유지 보수성을 향상시키는 데 중요합니다.

### 🙌 7번 원칙의 장점

- 1. **응집도 향상** : 한 객체는 그 객체의 핵심에 집중해야 합니다. 프로퍼티가 너무 많으면 해당 객체가 너무 많은 책임을 갖게 되어 객체의 응집도가 낮아집니다.
- 2. **가독성 향상** : 적은 수의 프로퍼티를 가진 객체는 더 명확하고 이해하기 쉽습니다.
- 3. **유지보수성 향상** : 프로퍼티 수가 제한되면 해당 객체의 범위와 책임이 명확해져 수정 및 확장이 용이해집니다.

### iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **책임 분리** : 한 객체가 여러 책임을 가지고 있다고 판단되면, 그 책임을 분리하여 여러 객체로 나눕니다.

```swift
// 나쁜 예
struct User {
    let name: String
    let email: String
    let age: Int
    let address: String
    let phoneNumber: String
}

// 좋은 예
struct Name {
    let firstName: String
    let lastName: String
}

struct ContactInfo {
    let email: String
    let phoneNumber: String
}

struct User {
    let name: Name
    let contactInfo: ContactInfo
    let age: Int
}
```

- 2. **엔티티 포장** : 기본 데이터 타입 대신 커스텀 타입을 사용하여 관련된 프로퍼티나 기능을 그룹화합니다.
- 3. **핵심 로직 집중** : 객체가 주로 처리해야 하는 핵심 로직에 집중하도록 프로퍼티와 메서드를 정의합니다.

### 🙌 7번 원칙 마무리

- 이 원칙을 따르면 객체는 그들의 핵심 책임에만 집중하게 되고, 전체 앱의 구조가 더욱 명확하고 유연해집니다. 이로 인해 iOS 앱의 품질과 확장성도 향상됩니다.

---

## 8번 원칙 : [일급 컬렉션](#일급-컬렉션)을 사용합니다.

8. **[일급 컬렉션](#일급-컬렉션)을 사용합니다.** : 이 원칙은 컬렉션을 다루는 로직을 그룹화하고 객체 지향적 설계를 촉진하는 데 중점을 둡니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙은 데이터와 그 데이터를 다루는 연산을 함께 묶어서 코드의 가독성과 재사용성을 향상시키는 데 중요합니다.

### 🙌 8번 원칙의 장점.

- 1. **응집도 향상** : 일급 컬렉션은 관련된 데이터와 그 데이터를 다루는 연산을 한곳에 모아 응집도를 높입니다.
- 2. **가독성 향상** : 일급 컬렉션을 사용하면, 컬렉션과 관련된 로직이 흩어져 있지 않고 한 곳에 집중되므로 코드의 가독성이 향상됩니다.
- 3. **재사용성 및 확장성 증가** : 특정한 연산이나 조건을 가진 컬렉션을 다루는 로직이 필요할 때, 해당 일급 컬렉션만 재사용하거나 확장하면 됩니다.

### iOS 프로그래밍에서 이 원칙을 적용하는 방법

- 1. **컬렉션 포장** : 기본 컬렉션 타입(예 : Array, Dictionary) 대신 커스텀 타입을 사용하여 컬렉션을 포장하고, 그와 관련된 연산을 그 안에 정의합니다.

```swift
// 일반 컬렉션 사용 예
let users: [User] = getUsers()

// 일급 컬렉션 사용 예
struct UserCollection {
    private var users: [User]
    
    var count: Int {
        return users.count
    }
    
    func filterByAge(age: Int) -> [User] {
        return users.filter { $0.age == age }
    }
    // ... (other related operations)
}
```

- 2. **캡슐화** : 일급 컬렉션 내부의 실제 컬렉션 데이터는 `private` 또는 `fileprivate`로 숨기고, 필요한 연산만을 외부에 제공하여 캡슐화를 강화합니다.
- 3. **핵심 연산 정의** : 일급 컬렉션에는 해당 컬렉션과 관련된 핵심 연산들만 정의하며, 그 외의 기능은 외부에서 확장하여 사용합니다.

### 🙌 8번 원칙 마무리
- 이 원칙을 따르면, 관련된 데이터와 연산이 함께 그룹화되어 코드의 명확성과 재사용성이 향상됩니다. 이를 통해 iOS 앱의 구조화 로직의 명확성이 증가하며, 코드 품질도 향상됩니다.

---

## 9번 원칙: getter/setter를 구현하지 않습니다.

9. **getter/setter를 구현하지 않습니다..** : 이 원칙은 객체의 상태를 직접적으로 노출시키지 않고, 객체의 행위 중심의 설계를 강조하는 것입니다.
    - iOS 프로그래밍, 특히 Swift에서, 이 원칙은 객체의 내부 상태를 보호하고, 객체 간의 책임과 역할을 명확하게 하는 데 중요합니다.

### 🙌 9번 원칙의 장점.

- 1. **캡슐화 강화** : 객체의 내부 상태를 직접 노출시키지 않음으로써 객체의 내부 구현을 보호하고 외부의 영향으로부터 격리시킵니다.
- 2. **유지보수성 향상** : 내부 상태에 직접 접근하는 것을 피함으로써, 나중에 객체의 내부 구조나 로직이 변경되더라도 외부에서 사용하는 코드는 영향을 받지 않게 됩니다.
- 3. **객체 지향적 설계 촉진** : 객체의 상태를 직접 변경하거나 조회하는 것이 아니라, 해당 객체에게 원하는 행위를 요청하는 방식으로 코드를 작성하게 되므로, 객체 지향적인 설계를 더욱 촉진하게 됩니다.

### 🙌 iOS 프로그래밍에서 이 원칙을 적용하는 방법.

- 1. **Computed Property 사용** : Swift의 computed property를 활용하여 내부 상태를 간접적으로 표현하거나 변경할 수 있게 만듭니다.

```swift
struct Circle {
    private var _radius: Double = 0.0
    
    var area: Double {
        return .pi * _radius * _radius
    }
    
    func setRadius(_ value: Double) {
        _radius = value
    }
}
```

- 2. **메서드 활용** : 객체의 상태를 변경하거나 조회하는 대신, 해당 객체의 행위를 정의하는 메서드를 제공합니다.

```swift
class Account {
    private var balance: Double = 0.0
    
    func deposit(amount: Double) {
        balance += amount
    }
    
    func withdraw(amount: Double) {
        balance -= amount
    }
    
    func currentBalance() -> Double {
        return balance
    }
}
```

- 3. **Access Control 활용** : Swift의 `private`나 `fileprivate` 접근 제어자를 사용하여 객체의 상태를 외부로부터 보호합니다.

### 🙌 9번 원칙 마무리

- 이 원칙을 따르면, 객체의 상태와 행위가 명확하게 구분되고, 객체의 책임과 역할이 명확해집니다. 이를 통해 iOS 앱의 구조와 로직의 명확헛이 증가하며, 코드의 품질도 향상됩니다.

---

## 🙌 객체 생활 체조 원칙(Object Calisthenics) 마무리

**🙋‍♂️ 이러한 원칙들은 단순한 규칙이 아니라 연습 목적으로 사용되며, 실제 개발 과정에서는 상황에 따라 유동적으로 적용해야 합니다. 이 원칙들을 따르면 객체 지향적인 설계와 코드의 품질을 높일 수 있습니다.**

---

# 객체 생활 체조 원칙(Object Calistenics)과 SOLID의 관계.

**✅ 객체 생활 체조 원칙(Object Calistenics)과 SOLID 원칙은 모두 좋은 객체 지향 설계와 깔끔한 코드를 작성하기 위한 지침들입니다. 두 원칙은 서로 다른 관계에서 접근하긴 하지만, 결국에는 코드의 품질을 높이고 유지보수를 용이하게 하는 공통의 목적을 가지고 있습니다.**</br>

주니어 iOS 프로그래머의 관점에서 이 두 원칙의 관계를 살펴보면 다음과 같습니다.

1. **목적** :
    - **SOLID** : 객체 지향 설계의 5가지 핵심 원칙으로, 클래스와 메서드의 설계와 책임에 중점을 둡니다.
    - **객체 생활 체조** : 코드의 가독성, 간결성 및 객체 지향성을 향상시키는 데 초점을 맞춘 연습 방법입니다.</br>

2. **적용 범위** :
    - **SOLID** : 설계 수준에서의 원칙입니다. 큰 구조와 시스템 아키텍처에 큰 영향을 줍니다.
    - **객체 생활 체조** : 더욱 세밀한 코드 수준에서의 원칙입니다. 일일이 코드를 작성하면서 주의해야 하는 사항들을 다룹니다.</br>

3. **관계** :
    - SOLID 원칙을 따르면서 코드를 작성하다면, 객체 생활 체조 원칙도 자연스럽게 지켜지는 경우가 많습니다. 예를 들어, SOLID의 Single Responsibility Principle(SRP)은 클래스가 한 가지 책임만 가져야 한다는 원칙입니다.
    - 이를 따르면, 객체 생활 체조의 "한 메서드에 오직 단일 레벨의 들여쓰기만을 사용한다"나 "2개 이하의 인스턴스 변수만 사용한다" 같은 원칙들이 자연스럽게 지켜질 수 있습니다.</br>

4. **실용성** :
    - 주니어 iOS 프로그래머로서, 처음에는 이런 원칙들이 다소 복잡하고 까다로울 수 있습니다. 그러나 이 원칙들을 실제 코드 작성에 연습하며 적용하면, iOS 앱의 설계와 코드 품질이 크게 향상될 것입니다.</br>

**🙋‍♂️ 결론적으로, SOLID와 객체 생활 체조 원칙은 서로 보완적인 관계에 있습니다. SOLID는 "무엇"을 해야하는지에 대한 지침을 제공하고, 객체 생활 체조 원칙은 "어떻게" 그것을 구현해야 하는지에 대한 지침을 제공합니다.**
- 두 원칙을 모두 잘 이해하고 적용하면, 주니어 iOS 프로그래머도 훌륭한 코드와 설계를 만들어낼 수 있습니다.

---

# OOP에서의 객체의 "책임", "역할", "협력"의 의미.

**✅ iOS 프로그래밍에서도 다른 플랫폼이나 언어와 마찬가지로 객체 지향 프로그래밍의 핵심 개념인 "객체의 책임", "객체의 역할", "객체의 협력"이 중요하게 작용합니다. iOS 앱의 컴포넌트, UI 컨트롤, 서비스 등 대부분의 것들은 객체로 표현됩니다.**</br>

1. **객체의 책임(Responsibility)** :
    - 각 객체는 특정한 책임과 업무를 가지고 있습니다. 이것은 객체가 수행해야 할 액션 또는 객체가 알아야할 정보를 의미합니다.
    - 예: iOS에서 `UIViewController` 객체의 주된 책임은 뷰 계층의 생명 주기를 관리하는 것 입니다. 또한 사용자의 인터렉션을 처리하거나 데이터를 뷰에 표시하는 것도 그 책임 중 일부입니다.</br>

2. **객체의 역할(Role)** :
    - 객체가 시스템 내에서 수행하는 특정한 역할을 의미합니다. 같은 책임을 가진 여러 객체가 서로 다른 역할을 수행할 수 있습니다.
    - 예: `UITableView`와 `UICollectionView`는 둘 다 아이템을 목록 형태로 표시하는 책임을 가지지만, 테이블 형태와 그리드 형태의 역할을 각각 수행합니다.</br>

3. **객체의 협력(Collaboration)** :
    - 객체들은 서로 독립적으로 존재하는 것이 아니라, 특정한 목표를 달성하기 위해 서로 협력합니다. 이때 객체들 사이에 메시지를 주고받게 되며, 이러한 메시지 전달을 통해 협력이 이루어집니다.
    - 예: iOS에서 사용자가 테이블 뷰의 셀을 탭하면, 해당 `UITableViewCell` 객체는 이벤트를 `UITableView`에 알립니다. 이후 `UITableView`는 이 정보를 대응하는 `UITableViewDelegate`에게 전달하고, 이러한 협력을 통해 셀 선택 이벤트가 처리됩니다.</br>

**🙋‍♂️ iOS 프로그래밍에서 이러한 객체 지향의 개념을 이해하고 적용하면, 유연하고 재사용 가능한 코드를 작성하는 데 큰 도움이 됩니다. 특히 iOS 프레임워크의 많은 부분이 객체 지향 설계 원칙을 기반으로 하고 있기 때문에, 이 개념들을 잘 이해하면 iOS 앱 개발의 효율성과 품질을 높일 수 있습니다.**

---

## 일급 컬렉션

**✅ 일급 컬렉션은 객체 지향 프로그래밍에서 중요한 개념 중 하나입니다.**

### 일급 컬렉션의 정의

**✅ 일급 컬렉션은 다음 두 가지 특성을 만족하는 컬렉션을 말합니다.**

1. **해당 클래스는 컬렉션(예 : 배열, 딕셔너리)을 멤버 변수로 가집니다.**
2. **해당 클래스는 다른 멤버 변수를 가지고 있지 않습니다**
    - 즉, 컬랙션 하나만을 멤버 변수로 가집니다.</br>

### 사용하는 이유

1. **비즈니스 로직을 한곳에 모아 관리** : 일급 컬렉션을 사용하면, 관련된 비즈니스 로직을 해당 컬렉션 내부에 캡슐화 할 수 있습니다.
2. **불변성 유지** : 일급 컬렉션 내부의 데이터를 변경하지 않고, 새로운 데이터가 필요할 때 새로운 일급 컬렉션을 반환할 수 있습니다.
3. **코드의 가독성 향상** : 의미 있는 메서드이름을 통해 코드의 가독성을 높일 수 있습니다.</br>

### iOS에서의 예시

```swift
struct Students {
    private var list: [Student]
    
    init(list: [Student]) {
        self.list = list
    }
    
    func count() -> Int {
        return list.count
    }
    
    func findTopScorer() -> Student? {
        return list.max(by: { $0.score < $1.score })
    }
} 
```

위의 `Students` 구조체는 일급 컬렉션의 예입니다.</br>

`Studnet` 객체들의 배열만을 멤버 변수로 가지고 있고, 학생들 중에서 가장 높은 점수를 받은 학생을 찾는 `findTopScorer`와 같은 로직을 내부에 캡슐화하고 있습니다.</br>

### 정리

일급 컬렉션을 사용하면, 단순한 배열이나 딕셔너리보다 더 의미 있는 도메인 객체를 생성할 수 있습니다.</br>

이를 통해 코드의 가독성을 높이고, 관련 로직을 한 곳에서 관리할 수 있게 됩니다.</br>

따라서, iOS 개발을 할 때도 이러한 원칙을 고려하여 모델을 설계하면, 더욱 효율적이고 관리하기 쉬운 코드를 작성할 수 있습니다.</br>

---

## 다형성

**✅ 다형성(Polymorphism)은 객체 지향 프로그래밍의 핵심 원칙 중 하나로, 이름은 같지만 다른 기능이나 데이터 타입으로 동작할 수 있게 하는 특징을 말합니다.**
- iOS 프로그래밍, 특히 Swift에서도 이 원칙은 중요한 역할을 합니다.</br>

### 다형성의 의미

1. **동일한 인터페이스, 다른 구현**
    - 다형성은 한 인터페이스나 부모 클래스를 공유하는 여러 객체들이 같은 메서드를 호출해도 각 객체의 타입에 맞는 적절한 동작을 수행하도록 합니다.</br>

2. **확장성**
    - 다형성을 사용하면 코드를 수정하지 않고도 새로운 객체 타입을 쉽게 추가할 수 있습니다.</br>

3. **코드 재사용**
    - 특정 동작을 수행하는 코드를 여러 타입의 객체에 적용할 수 있어 코드 중복이 줄어듭니다.</br>

### iOS 프로그래밍에서의 다형성

1. **프로토콜(Protocols)** : Swift의 프로토콜은 다형성의 강력한 도구입니다. 여러 클래스나 구조체가 동일한 프로토콜을 채택하면, 그들 모두는 프로토콜에 정의된 메서드와 속성을 가지게 됩니다. 이를 통해 각각의 구현체는 동일한 메서드 명을 사용하지만, 그 내부의 구현을 다를 수 있습니다.</br>

```swift
protocol SoundProducing {
    func makeSound()
}

class Dog: SoundProducing {
    func makeSound() {
        print("Bark!")
    }
}

class Cat: SoundProducing {
    func makeSound() {
        print("Meow!")
    }
}

let animals: [SoundProducing] = [Dog(), Cat()]

for animal in animals {
    animal.makeSound() // 각각의 구현에 따라 Bark! 또는 Meow! 출력
}
```

2. **상속** : 클래스 상속을 통해 부모 클래스의 특성을 자식 클래스가 상속받아, 같은 메서드명을 사용하면서도 다른 동작을 수행하게 할 수 있습니다.

```swift
class Animal {
    func eat() {
        print("Eating food.")
    }
}

class Bird: Animal {
    override func eat() {
        print("Eating seeds.")
    }
}

let bird = Bird()
bird.eat() // "Eating seed." 출력
```

### 다형성 마무리

다형성을 사용하면 코드가 더욱 유연해지고, 여러 타입의 객체를 한번에 처리할 수 있게 됩니다. 이를 통해, iOS 앱 개발에서의 코드 중복을 줄이고, 확장성을 향상시킬 수 있습니다.

---
