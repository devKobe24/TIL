# 1️⃣ Swift 클로저가 주변 범위의 변수를 캡처할 수 있는 능력💪

Swift의 클로저가 주변 범위의 변수를 캡저할 수 있는 능력은 클로저가 정의될 때의 컨텍스트를 "기억"하고, 클로저가 실행될 때의 그 컨텍스트에 있는 변수들에 접근할 수 있도록 설계되었기 때문입니다 👀.

이는 클로저 자신이 생성된 범위의 환경을 캡처📸하고 사용할 수 있게하여, 함수형 프로그래밍 패턴을 지원하고, 비동기 작업, 콜백 처리, 고차 함수 등에 있어 강력한 표현력을 제공합니다.

클로저가 변수를 캡처하는 방식은 몇 가지 중요한 이유에 의해 지원됩니다.

## ✅ 클로저가 변수를 캡처하는 방식.

### 1. 렉시컬 스코프.

Swift는 **렉시컬 스코핑(lexical scoping)** 을 사용합니다.
이는 변수가 코드에서 정의된 위치에 의해 접근성이 결여된다는 것을 의미합니다.
클로저 내에서 사용되는 변수들은 클로저가 정의된 그 순간의 스코프에 따라 결정되므로, 클로저는 이러한 변수들을 "캡처"하여 사용할 수 있습니다.

### 2. 참조 세마틱스.

클로저에 의해 캡처된 변수들은 **참조에 의해 캡처될 수 있습니다.**
이는 클로저가 변수의 실제 인스턴스를 참조하고 있으므로, 클로저 외부에서 변수가 변하면 클로저 내부에서도 그 변경 사항이 반영됩니다.

### 3. 메모리 관리.

Swift는 **자동 참조 카운트(ARC)를 통해 메모리를 관리**합니다.
클로저에 의해 캡처된 변수들은 클로저가 존재하는 동안 메모리에서 해제되지 않도록 보장됩니다.
이는 클로저가 그 변수들을 안전하게 사용할 수 있게 합니다.

### 4. 함수형 기능.

클로저는 Swift에서 **함수형 프로그래밍 기능을 제공**합니다.
클로저를 통해 변수를 캡처하면, 클로저는 하나의 독립적인 작업 단위로서 주변 환경에 대한 정보를 내장하여 사용할 수 있습니다.

# 💯 Swift 클로저가 주변 범위의 변수를 캡처할 수 있는 능력 마무리.

클로저에 의한 변수 캡처는 Swift 프로그래밍에서 유용한 도구로, 비동기 작업, 이벤트 핸들링, 커스텀 정렬 연산, 타이머 콜백 등 다양한 상황에서 중요한 역할을 수행합니다.

# 2️⃣ 렉시컬 스코핑(lexical scoping)🤔?

**렉시컬 스코핑(lexical scoping)** 은 프로그래밍 언어에서 변수의 접근성이 그 변수가 코드 내에서 선언된 위치에 의해 결정되는 범위 결정 규칙을 의미합니다.

즉, 변수가 접근 가능한 영역은 그 변수가 텍스트상으로 어디에 작성되었는지에 따라 결정됩니다.

이 개념을 이해하기 위해 다음과 같은 특징을 살펴볼 수 있습니다.

## ✅ 렉시컬 스코핑(lexical scoping)을 이해하기 위한 특징.

### 1. 정적 범위 결정.

**렉시컬 스코핑(lexical scoping)** 은 코드를 작성하는 시점에서 변수의 스코프가 결정된다는 것을 의미합니다.
이는 프로그램이 실행되는 동안 변경되지 않습니다.

### 2. 블록 기반 스코프.

**렉시컬 스코핑(lexical scoping)** 은 보통 블록 기반(block-based)입니다.
즉, 변수는 함수, 조건문, 루프 등 특정 코드 블록 내에서 선언되고, 그 블록과 그 하위 블록에서만 접근 가능합니다.

### 3. 클로저와의 관계.

**렉시컬 스코핑(lexical scoping)** 은 클로저의 동작 방식에 큰 영향은 줍니다.
클로저는 자신이 생성된 렉시컬 스코프의 변수들을 캡처할 수 있습니다.
이는 클로저가 정의된 시점의 변수들을 사용할 수 있게 하며, 클로저가 실행될 때 해당 변수들에 대한 참조를 유지합니다.

# 💯 렉시컬 스코핑(lexical scoping) 마무리.

**렉시컬 스코핑(lexical scoping)** 은 프로그래밍에서 변수의 유효 범위와 생명주기를 명확하게 정의하여 코드의 가독성과 유지보수성을 향상시킵니다.
Swift와 같은 현대 프로그래밍 언어는 이런 **렉시컬 스코핑(lexical scoping) 방식** 을 사용하여 프로그래머가 코드의 동작을 더 쉽게 이해하고 예측할 수 있도록 돕습니다.

# 3️⃣ 어떻게 클로저가 정의 될 때의 컨택스트를 "기억"하고 클로저가 실행될 때 그 컨텍스트에 있는 변수들에 "접근"할 수 있을까🤔?

클로저가 자신이 정의될 때의 컨텍스트를 "기억"하고, 실행될 때 그 켄텍스트에 있는 변수들에 "접근"할 수 있는 능력은 클로저의 내부 구현에 의해 가능해 집니다.

Swift에서 클로저는 **캡처 리스트(capture list)** 를 통해 정의 시점의 변수를 참조하거나 복사하여 내부 상태로 저장합니다.

이를 통해 클로저는 외부 스코츠의 변수들을 사용할 수 있습니다.

이 과정은 다음과 같은 방식으로 작동합니다.

## ✅ 과정.

### 1. 클로저 정의 시.
클로저가 정의 할 때, 클로저 내부에서 사용되는 외부 변수들은 캡처됩니다.
캡처는 변수를 참조하거나 값으로 복사하는 것을 의미할 수 있습니다.
Swift에서는 캡처 리스트를 사용하여 이를 명시적으로 제어할 수 있습니다.

### 2. 참조 캡처.
클로저가 변수를 참조로 캡처할 경우, 해당 변수의 참조 카운트가 증가하여 메모리에서 해제되지 않도록 보장됩니다.
클로저 내부에서 이 변수를 사용할 때는 원본 변수의 최신 값을 사용할 수 있습니다.

### 3. 값 캡처.
클로저가 변수를 값으로 캡처할 경우, 클로저가 생성될 때의 변수의 복사본이 클로저 내부에 저장됩니다.
이후 클로저가 실행될 때, 캡처된 변수의 복사본에 접근하여 사용할 수 있습니다.

### 4. 클로저 실행 시.
클로저가 실행될 때, 클로저는 이전에 캡처한 변수들을 사용하여 작업을 수행합니다.
클로저에 의해 캡처된 변수들은 클로저가 존재하는 한 메모리에서 유지됩니다.

# 💯 클로저가 정의 될 때의 컨택스트를 "기억"하고 클로저가 실행될 때 그 컨텍스트에 있는 변수들에 "접근"할 수 있을까? 마무리.

클로저에 의한 캡처 메커니즘은 프로그래밍에서 매우 유용한 기능입니다.
클로저를 사용하여 비동기 호출, 콜백 함수, 고차 함수 등에서 필요한 상태를 유지하고, 외부 변수와의 상호 작용을 수행할 수 있게 해줍니다.
Swift의 클로저는 이러한 기능을 간단하고 안전하게 사용할 수 있도록 설계되어 있습니다.

# 4️⃣ 캡처 리스트(Capture list)🤔?

Swift에서 **캡처 리스트(Capture list)** 는 클로저가 외부 스코프에 있는 변수들을 어떻게 캡처할지 명시적으로 정의하는 구문입니다.

클로저는 자신이 정의된 컨텍스트의 변수들을 캡처할 수 있는데, 이때 캡처 리스트를 사용하여 캡처 방식을 정밀하게 제어할 수 있습니다.

## ✅ 캡처 리스트(Capture list)의 주요 기능.

### 1. 참조 방식 명시.

**캡처 리스트(Capture list)** 를 통해 클로저가 변수를 값으로 복사할지, 아니면 참조로 캡처할지를 결정할 수 있습니다.
이를 통해 메모리 관리 및 변수의 생명주기를 효과적으로 제어할 수 있습니다.

### 2. 메모리 관리 최적화.

특히 **참조 타입의 객체를 캡처**할 때, **캡처 리스트(Capture list)** 는 순환 참조(retain cycle)을 방지하는 데 도움을 줍니다.
**`'weak'`** 또는 **`'unowned'`** 키워드를 사용하여 캡처된 참조가 소유권을 가지지 않도록 설정할 수 있습니다.

### 3. 캡처 시점의 상태 보존.

**값 타입의 변수를 캡처**할 때, **캡처 리스트(Capture list)** 는 클로저가 정의된 시점의 변수 상태를 복사하여 저장합니다.
이는 클로저 내에서 변수가 변경되지 않도록 보장하며, 클로저 실행 시 안정성을 높여줍니다.

### 4. 캡처 리스트의 사용 예시.

```swift
var number = 77
let closure = { [number] in
    print(number)
}
number = 7
closure() // 77을 출력
```

여기서 **캡처 리스트(Capture list) `[number]`** 는 클로저가 생성될 때 **'number'** 변수의 값을 캡처합니다.
따라서 클로저 내부에서 **'number'** 는 캡처된 시점의 값인 42를 유지합니다.

# 💯 캡처 리스트(Capture list) 마무리.

이와 같이 **캡처 리스트(Capture list)** 는 클로저가 외부 변수를 사용할 때 발생할 수 있는 다양한 문제를 해결하고, 더 명확하고 예측 가능한 동작을 구현하는 데 도움을 줍니다.

# 5️⃣ Swift에서의 참조 세마틱스(Reference semantics)🤔?

**Swift에서의 참조 세마틱스(Reference semantics)** 는 객체가 참조를 통해 관리되고 접근되는 방식을 말합니다.

Swift에서 클래스(class)는 **참조 타입(reference type)** 으로, **참조 세마틱스(Reference semantics)를 따릅니다.**

**이는 클래스 인스턴스가 메모리에 한 번 저장되고, 해당 인스턴스에 대한 참조가 여러 곳에서 공유될 수 있음을 의미합니다.**

## ✅ Swift의 참조 세마틱스(Reference sematics)의 주요 특징.

### 1. 공유 인스턴스.

클래스 인스턴스는 여러 변수나 상수에 의해 참조될 수 있으며, 이러한 변수나 상수는 모두 동일한 메모리에 위치한 단일 인스턴스를 가리킵니다.

**따라서 인스턴스의 상태가 한 곳에서 변경되면, 다른 모든 참조를 통해서도 이 변경 사항이 관찰될 수 있습니다.**

### 2. 자동 참조 카운팅(ARC).

Swfit는 자동 참조 카운팅(ARC)을 사용하여 클래스 인스턴스의 생명 주기를 관리합니다.

ARC는 인스턴스를 참조하는 각 변수나 상수에 대해 참조 카운트를 유지하고, 참조 카운트가 0이 되면 인스턴스를 메모리에서 해제합니다.

### 3. 순환 참조 방지.

클래스 간의 **강한 순환 참조(Strong reference cycle)** 은 **메모리 누수(Memory leak)** 를 야기할 수 있습니다.

Swift는 이를 방지하기 위해 **'`약한(weak)`'** 와 **'`미소유(unowned)`'** 참조를 제공합니다.

이러한 참조들은 참조 카운트에 영향을 주지 않아 순환 참조를 방지합니다.

### 4. 상속과 다형성.

클래스는 **상속**을 통해 기능을 확장하고, **다형성**을 지원합니다.

이는 **참조 세마틱스(Reference sematics)** 를 통해 **부모 클래스의 인스턴스를 자식 클래스의 타입으로 참조**하거나, **프로토콜을 채택하여 여러 타입을 동일한 방식으로 다룰 수 있게** 합니다.

### 5. 메모리 효율성과 성능.

**참조 세마틱스(Reference sematics)** 는 대규모 데이터 구조의 효율적인 관리를 가능하게 합니다.

**데이터를 복사하는 대신 참조를 전달함으로써 메모리 사용을 최적화하고 성능을 향상**시킬 수 있습니다.

# 💯 Swift의 참조 세마틱스(Reference sematics) 마무리.

**참조 세마틱스(Reference sematics)** 는 Swift 프로그래밍에서 중요한 역할을 하며, 클래스를 사용할 때 이해하고 고려해야 할 핵심 개념입니다.

객체 지향 프로그래밍의 다양한 특성을 활용하고, 메모리 관리를 효과적으로 수행하는 데 중요한 역할을 합니다.

---

## 참고 자료 📚

- [다형성(Polymorphism)과 Swift에서의 다형성.](https://github.com/devKobe24/TIL/blob/main/TIL/231119(3)_TIL.md)
