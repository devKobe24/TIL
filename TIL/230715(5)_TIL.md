# global().sync 👀</br>

```swift!
DispatchQueue.global().async {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

DispatchQueue.global().async {
	for _ in 1...5 {
		print("🥶🥶🥶🥶🥶")
		sleep(2)
	}
}

DispatchQueue.main.async {
	for _ in 1...5 {
		print("🥵🥵🥵🥵🥵")
		sleep(1)
	}
}

/* 출력 결과(랜덤)
😀😀😀😀😀
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
😀😀😀😀😀
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
😀😀😀😀😀
🥵🥵🥵🥵🥵
😀😀😀😀😀
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
😀😀😀😀😀
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
*/
```

이번에는 main 스레드가 아닌 `다른 스레드`를 만들어 `비동기`적으로 작업을 처리해주고 있습니다.
출력 결과를 보면 동시에 작업을 처리하는 코드입니다.
이처럼 동시에 작업이 처리되기 위해서는 `여러 개의 스레드`가 필요하고, `비동기`로 작업이 처리되어야 합니다.

하지만 이때 **어떤 코드가 먼저 실행될지는 예측할 수가 없습니다.**
바로 위에서 언급했던 async의 특성 때문입니다.

또한 각 스레드마다 작업이 처리되는 속도가 다를 수 있으며 이는 직접 통제할 수는 없습니다.
그러므로 동시에 처리되는 작업에 대해서는 **논리적으로 정확한 순서를 기대하기는 어렵습니다.**
우리의 손을 떠난 순간부터는 예측할 수 없는 것입니다.
실행마다 결과가 달리 보이는 것도 이러한 이유입니다.

global().async를 이미지로 표현하면 아래와 같습니다.
**global 스레드에서 작업이 끝나면 해당 스레드는 메모리에서 제거됩니다.**</br>

<img src = "https://github.com/devKobe24/images/blob/main/syncAndAsync3.gif?raw=true"></br>
