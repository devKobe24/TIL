# 230713 GCD의 이해 📓

## 1️⃣ 번 예시
```swift!
let red = DispatchWorkItem {
	for _ in 1...5 {
		print("🥵🥵🥵🥵🥵")
		sleep(1)
	}
}

let yellow = DispatchWorkItem {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

let blue = DispatchWorkItem {
	for _ in 1...5 {
		print("🥶🥶🥶🥶🥶")
		sleep(2)
	}
}

DispatchQueue.global().sync(execute: yellow)
DispatchQueue.global().async(execute: blue)
DispatchQueue.main.async(execute: red)

/* 출력 결과
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
*/
```

### 위 코드의 실행 결과를 이해하기 위해서는 먼저 각 메소드의 동작 방식을 이해해야 합니다.</br>
1. `DispatchQueue.global().sync(execute: yellow)`
이 코드는 `yellow` 작업을 글로벌 큐에 동기적으로 등록합니다.
**💡 이 말은 해당 작업이 완료될 때까지 다음 코드 실행을 차단한다는 것을 의미합니다.**
즉, `yellow` 작업이 완료될 때까지 `blue` 작업은 시작되지 않습니다.

2. `DispatchQueue.global().async(execute: blue)`
이 코드는 `blue` 작업을 글로벌 큐에 비동기적으로 등록합니다.
**💡 비동기적인 실행은 작업이 백그라운드에서 수행되고 
`blue` 작업이 완료되기를 기다리지 않고 즉시 다음 코드인 `red` 작업으로 넘어간다는 것을 의미합니다.**

3. `DispatchQueue.main.async(execute: red)`
이 코드는 `red` 작업을 메인 큐에 비동기적으로 등록합니다.
메인 큐는 일반적으로 사용자 인터페이스를 업데이트하는 데 사용되며,
이 작업은 UI 관련 작업에 대한 응답성을 유지하기 위해 메인 스레드에서 실행됩니다.
**💡 이 메소드 호출은 즉시 반환되며, `red` 작업은 백그라운드에서 계속 실행됩니다.**

**🙌 따라서, 위 코드를 실행하면 다음과 같은 순서로 출력이 아루어집니다.**

1️⃣ `yellow` 작업이 처음에 동기적으로 실행되므로, "😀😀😀😀😀"가 5번 출력된 후에 `blue`와 `red` 작업이 실행됩니다.</br>
2️⃣ `blue`와 `red` 작업이 거의 동시에 비동기적으로 실행되지만, `blue` 작업은 2초의 sleep이 있으므로 `red` 작업이 먼저 완료될 가능성이 높습니다. 따라서 "🥵🥵🥵🥵🥵"와 "🥶🥶🥶🥶🥶"가 교차로 출력되지만, 대부분 "🥵🥵🥵🥵🥵"가 먼저 완전히 출력되고 나서 "🥶🥶🥶🥶🥶"가 출력됩니다.</br>

**🚨 그러나 이러한 출력 순서는 다양한 요인에 따라 달라질 수 있습니다. 실행 환경, CPU의 상태, 스레딩 모델 등의 요인에 따라 실제 결과는 약간 달라질 수 있습니다.**

---

## 2️⃣ 번 예시

```swift!
let red = DispatchWorkItem {
	for _ in 1...5 {
		print("🥵🥵🥵🥵🥵")
		sleep(1)
	}
}

let yellow = DispatchWorkItem {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

let blue = DispatchWorkItem {
	for _ in 1...5 {
		print("🥶🥶🥶🥶🥶")
		sleep(2)
	}
}

DispatchQueue.global().async(execute: yellow)
DispatchQueue.global().sync(execute: blue)
DispatchQueue.main.async(execute: red)

/* 출력 결과
🥶🥶🥶🥶🥶
😀😀😀😀😀
😀😀😀😀😀
🥶🥶🥶🥶🥶
😀😀😀😀😀
😀😀😀😀😀
🥶🥶🥶🥶🥶
😀😀😀😀😀
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
*/
```

### 위 코드의 실행 결과를 이해하려면 `async`, `sync`, 그리고 `DispatchQueue.main` 및 `DispatchQueue.global()`의 작동 방식을 이해해야 합니다.</br>
1. `DispatchQueue.global().async(execute: yellow)`
이 코드는 `yellow` 작업을 글로벌 디스패치 큐에 비동기적으로 제출합니다.
**💡 이는 작업이 백그라운드에서 실행되며, 이 호출이 즉시 반환되어 다음 줄의 코드를 실행한다는 것을 의미합니다.**
이 경우, `yellow` 작업은 백그라운드에서 실행되고 "😀😀😀😀😀"를 5번 출력한 후에 완료됩니다.

2. `DispatchQueue.global().sync(execute: blue)`
이 코드는 `blue` 작업을 글로벌 디스패치 큐에 동기적으로 제출합니다.
**💡 이는 작업이 완료될 때까지 이 줄에서 실행을 차단한다는 것을 의미합니다.**
즉, `blue` 작업이 "🥶🥶🥶🥶🥶"를 5번 출력하고 sleep(2) 동안 일시 중지한 후에 완료되어야 다음 줄의 코드가 실행됩니다.

3. `DispatchQueue.main.async(execute: red)`
이 코드는 `red` 작업을 메인 디스패치 큐에 비동기적으로 제출합니다.
**💡 이는 작업이 메인 스레드에서 실행되지만, 이 호출이 즉시 반환되어서 바로 다음 코드를 실행한다는 것을 의미합니다.**
`red` 작업은 메인 스레드에서 실행되므로 UI 업데이트와 같은 작업에 적합합니다.
여기서는 "🥵🥵🥵🥵🥵"를 5번 출력하게 됩니다.

**🙌 따라서, 위의 코드를 실행하면 다음과 같은 출력 순서가 예상됩니다.**

1️⃣ `yellow` 작업과 `blue` 작업은 거의 동시에 시작됩니다.
`yellow` 작업은 백그라운드에서 실행되므로 `blue` 작업이 시작되는 것을 차단하지 않습니다.
그러나 `blue` 작업은 동기적으로 실행되므로, `red` 작업은 `blue` 작업이 완료될 때까지 시작되지 않습니다.
따라서 "😀😀😀😀😀"와 "🥶🥶🥶🥶🥶"가 혼합되어 출력됩니다.

2️⃣ `blue` 작업이 완료되면 `red` 작업이 시작됩니다 이는 `blue` 작업이 동기적으로 실행되므로,
`blue` 작업이 완료되어야만 `red` 작업이 시작될 수 있기 때문입니다.
따라서 `blue` 작업이 완료된 후에 "🥵🥵🥵🥵🥵"가 5번 출력됩니다.

**🚨 그러나 이는 이상적인 시나리오며, 실제로는 스케줄링, 스레드 대기 시간, 실행 환경 등 여러 요인에 따라 결과가 다소 달라질 수 있습니다. 따라서 실제 출력은 위의 설명과 완전히 일치하지 않을 수 있습니다.**

---

## 3️⃣ 번 예시
```swift!
let red = DispatchWorkItem {
	for _ in 1...5 {
		print("🥵🥵🥵🥵🥵")
		sleep(1)
	}
}

let yellow = DispatchWorkItem {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

let blue = DispatchWorkItem {
	for _ in 1...5 {
		print("🥶🥶🥶🥶🥶")
		sleep(2)
	}
}

DispatchQueue.main.async(execute: yellow)
DispatchQueue.global().async(execute: blue)
DispatchQueue.global().sync(execute: red)

/* 출력 결과
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥵🥵🥵🥵🥵
🥶🥶🥶🥶🥶
😀😀😀😀😀
🥶🥶🥶🥶🥶
😀😀😀😀😀
😀😀😀😀😀
🥶🥶🥶🥶🥶
😀😀😀😀😀
😀😀😀😀😀
*/
```

### 이 코드는 Swift에서 제공하는 DispatchWorkItem과 DispatchQueue를 사용하여 비동기 및 동기 작업을 처리하는 것을 보여줍니다.</br>

여기서 `DispatchWorkItem`은 특정 작업을 캡슐화하는 데 사용되며, `DispatchQueue`는 이러한 작업을 관리하고 실행하는 데 사용됩니다.

**💡 이 경우, yellow, blue, red 라는 세 가지 작업을 다음과 같이 실행하고 있습니다.**

1. `DispatchQueue.main.async(execute: yellow)`
메인 큐에 yellow 작업을 비동기적으로 제출합니다.
**💡 메인 큐는 일반적으로 사용자 인터페이스 관련 작업에 사용되며, 메인 스레드에서 실행됩니다.**
**💡 이 작업은 메인 스레드에서 다른 비동기 작업이 완료된 후에 실행됩니다.**
이 코드는 "yellow" 작업을 메인 큐에 비동기적으로 전달하라는 의미입니다.
"메인 큐"는 모든 UI 업데이트를 처리하는 큐이며, 일반적으로 메인 스레드에서 작동합니다.
`async` 키워드는 작업을 큐에 전달하고, 그 큐가 작업을 언제 시작할지 결정하게 합니다.
이 경우, 메인 큐가 현재 다른 작업을 처리하고 있지 않다면 "yellow" 작업이 곧바로 시작될 것 입니다.
하지만 메인 큐가 현재 다른 작업을 처리하고 있다면 "yellow" 작업은 그 작업이 완료될 때까지 대기 상태에 있게 됩니다.


2. `DispatchQueue.global().async(execute: blue)`
글로벌 큐에 blue 작업을 비동기적으로 제출합니다.
**💡 글로벌 큐는 백그라운드에서 실행되며, CPU에 따라 여러 스레드에서 동시에 작업을 실행할 수 있습니다.**
**💡 비동기적으로 실행되므로, 다른 작업들이 동시에 실행될 수 있습니다.**
이 코드는 "blue" 작업을 글로벌 디스패치 큐에 비동기적으로 전달하라는 의미입니다.
글로벌 디스패치 큐는 시스템에서 제공하는 병렬 작업 큐로, 주로 백그라운드에서 실행될 비-UI 작업을 위해 사용됩니다.
이 작업도 `async` 키워드를 사용하므로, 작업은 큐에 전달된 즉시 시작되지 않을 수 있습니다.
대신, 이 작업은 시스템에 의해 스케줄링되고, 실행을 위해 스레드가 사용 가능해질 때까지 대기 상태에 놓입니다.

3. `DispatchQueue.global().sync(execute: red)`
글로벌 큐에 red 작업을 동기적으로 제출합니다.
**💡 동기적으로 실행되므로 이 작업이 완료될 때까지 다음 작업은 실행되지 않습니다.**
이 코드는 "red" 작업을 글로벌 디스패치 큐에 동기적으로 전달하라는 의미입니다.
`sync` 키워드는 작업이 큐에 전달된 즉시 시작되어야 함을 나타냅니다.
더 정확히 말하자면 `sync` 키워드는 작업이 완료될 때까지 현재의 실행 흐름을 차단합니다.
이 경우 "red" 작업은 큐에 전달되자마자 시작되며, 이작업이 완료될 때까지 이후의 코드는 실행되지 않습니다.

**이 코드를 실행하면 "yellow", "blue", "red" 작업이 모두 실행됩니다.**
그러나 `async` 작업은 큐에 전달되자마자 즉시 실행되지 않을 수 있으므로, 
"yellow" 작업과 "blue" 작업의 시작 순서는 예측할 수 없습니다.
또한 "blue" 작업은 "red" 작업이 완료 될 때까지 시작되지 않을 수 있습니다.
이는 "red" 작업이 동기적으로 실행되므로, 이 작업이 완료되지 전까지는 어떤 다른 작업도 실행되지 않기 때문입니다.
이러한 동작은 작업이 큐에 전달되는 방식(`async` vs `sync`)과 작업이 전달되는 종류(메인 큐 vs 글로벌 큐)에 따라 달라집니다.

**🙌 따라서 이러한 작업이 출력되는 순서는 다음과 같습니다.**

1️⃣ 먼저 `DispatchQueue.main.async(execute: yellow)`를 통해 `yellow` 작업이 메인 큐에 비동기적으로 전달됩니다.
하지만, 이 코드는 일반적으로 메인 스레드에서 실행되는 UI 작업을 처리하는 메인 큐에 추가되었으므로,
실행 순서가 다소 불확실합니다.
만약 메인 스레드가 다른 작업을 처리하고 있다면, `yellow` 작업은 그 작업이 끝나기를 기다려야 합니다.</br>

2️⃣ 그 다음, `DispatchQueue.global().async(execute: blue)`를 통해 `blue` 작업이 글로벌 큐에 비동기적으로 전달됩니다.
이 작업도 비동기적이므로, 스레드 풀에서 사용 가능한 스레드가 생길 때까지 기다린 후 실행됩니다.</br>

3️⃣ 마지막으로 `DispatchQueue.global().sync(execute: red)`를 통해 `red` 작업이 글로벌 큐에 동기적으로 전달됩니다.
이 작업은 동기적으로 수행되므로, 이 코드를 호출한 쓰레드는 `red` 작업이 완료될 때까지 기다립니다.
따라서 `red` 작업은 큐에 추가되자마자 즉시 실행되며, 이 작업이 완료되기 전까지 다른 어떤 작업도 실행되지 않습니다.

따라서 이 출력 순서는 다음과 같을 것입니다.

1. `red` 작업: 이 작업은 동기적으로 실행되므로, 큐에 추가되자마자 즉시 실행됩니다.
2. `blue` 작업 : 이 작업은 비동기적으로 실행되지만, `red` 작업이 완료될 때까지 기다렸다가 실행됩니다.
3. `yellow` 작업 : 이 작업은 메인 큐에서 비동기적으로 실행되므로, 메인 큐가 비워질 때까지 기다린 후 실행됩니다.

**🚨 하지만, 이러한 순서는 항상 보장되는 것은 아닙니다. 비동기 작업의 실행 순서는 여러 가지 요인, 
예를 들어 스레드의 가용성, 시스템의 로드, 운영 체제의 스케줄링 정책 등의 의해 영향을 받을 수 있습니다. 
따라서 실제 실행 결과는 실행할 때마다 달라질 수 있습니다.**
