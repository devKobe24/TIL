# Array(3)
---

### 🙋‍♂️ Topic
- 1️⃣ **새로운 요소 추가하기**
- 2️⃣ **요소 삭제하기**

---

✏️ **새로운 요소 추가하기**

'let' 키워드와 'var' 키워드가 가변성을 결정합니다.
요소를 추가하거나 삭제해야 한다면 'var' 키워드를 사용해야 합니다.

```swift!
var mutableAlphabet = ["A", "B", "C"]
```

배열에 새로운 값을 추가할 때 'append'를 사용할 수 있습니다.

```swift!
mutableAlphabet.append("E") // ["A", "B", "C", "E"]
```

위의 코드와 같이 'append' 메소드로 하나의 요소를 추가할 수 있습니다.

여러개의 요소를 동시에 추가하고 싶다면 'append(contentsOf:)' 메소드를 사용합니다.
파라미터로는 배열을 전달하면 됩니다.
```swift!
muatbleAlphabet.append(contentsOf: ["F", "G"]) // ["A","B","C","E","F","G"]
```

추가하는 요소가 배열의 뒤에 계속해서 추가되는 것을 볼 수 있습니다.

위 코드를 보면 ["A","B","C","E","F","G"] "C" 다음 "D" 가 빠져있는 것을 볼 수 있습니다.

이렇게 중간에 요소를 추가할 땐 'insert' 메서드를 사용합니다.
```swift!
mutableAlphabet.insert("D", at: 3) // ["A","B","C","D",E","F","G"]
```
append 메서드와 다른 점은 들어갈 위치를 파라미터로 받는다는 점 입니다.

이번에는 배열의 시작 부분에 소문자 "a","b","c"를 추가해보겠습니다.

```swift!
mutableAlphabet.insert(contentsOf: ["a", "b", "c"], at: 0) // ["a","b","c","A","B","C","D",E","F","G"]
```
추가할 요소를 contentsOf 파라미터의 배열로 전달하고 추가할 위치(인덱스)를 at에 전달하면 됩니다.

✅ append 메소드는 배열 뒤쪽에 새로운 요소를 추가합니다 </br>
따라서 overhead가 없습니다.
그 이유는 뒤에 요소를 추가한다고해서 앞에 있는 요소들이 움직이거나 바뀌지 않기 때문입니다.

✅ insert 메소드는 배열의 원하는 위치에 새로운 요소를 추가합니다 </br>
만약 insert로 요소를 중간이나 맨 앞에 추가할 경우 overhead가 발생합니다.
그 이유는 요소를 맨 앞이나 중간에 추가할 경우 요소들이 움직여야 하기 때문입니다.

✅ Overhead는 이동하는 요소가 많아질수록 더욱더 커집니다. </br>
물론 이것은 이론적인 것 입니다.
우리가 배열을 사용할 때, 보통 100~1000개 정도의 요소를 담은 배열을 사용합니다.
요즘은 디바이스의 성능이 매우 좋아 'append'를 하건 'insert'를 하건 차이를 느끼기에는 어렵습니다.

**하지만 차이점은 알고 있어야 합니다.**
최대한 Overhead가 없는 쪽으로 구현하는 것이 좋습니다.

이번에는 요소를 바꿔보겠습니다.
앞에 있는 "a","b","c"를 "x","y","z"로 바꿔보겠습니다.

방법은 두가지가 있습니다.
**먼저 Subscript 방법을 사용해보겠습니다.**

```swift!
mutableAlphabet[0...2] = ["x", "y", "z"]
mutableAlphabet // ["x","y","z","A","B","C","D",E","F","G"]
```
[0...2] 와 같이 바꿀 범위를 전달합니다.
그리고 여기에 새로운 배열을 저장하면 됩니다
그러면 지정한 범위에 저장되어있던 요소가 새로운 배열의 요소로 바뀝니다.

위와 똑같은 코드를 'replaceSubrange'메서드를 사용해 구현해보겠습니다.
첫 번째 파라미터로는 바꿀 범위를 전달하고, 두 번째 파라미터로 배열을 전달하면 됩니다.

```swift!
mutableAlphabet.replaceSubrange(0...2, with: ["x", "y", "z"]) // ["x","y","z","A","B","C","D",E","F","G"]
```
결과는 똑같은 것을 볼 수 있습니다.

하지만 반드시 동일한 갯수로 요소를 바꿀 수 있는 것은 아닙니다.

예시를 통해 알아봅시다
```swift!
mutableAlphabet[0...2] = ["z"]
mutableAlphabet // ["z","A","B","C","D",E","F","G"]
```

✅ 빈 배열을 저장하는 것은 요소를 삭제하는 것과 같습니다.</br>
```swift!
mutableAlphabet[0..<1] = [] // ArraySlice([])
mutableAlphabet // ["A","B","C","D",E","F","G"]
```
위 코드를 보면 앞에 있던 소문자 "z"가 삭제된 것을 볼 수 있습니다.

---

✏️ **요소 삭제하기**

remove를 입력시 자동 완성 기능으로 자동 완성되어 remove로 시작되는 메서드가 굉장히 많은 것을 볼 수 있습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%206.32.58.png?raw=true)

'remove(at:)' 메서드부터 알아봅시다.

'remove(at:)'은 파라미터가 하나입니다.
여기에 인덱스를 전달하면 해당 인덱스가 삭제됩니다.
만약에 배열에서 "C"를 삭제하고 싶다면 인덱스 2를 전달하면 됩니다.
```swift!
var alphabet = ["A", "B", "C", "D", "E", "F", "G"]
alphabet.remove(at: 2) // "C"
alphabet // ["A", "B", "D", "E", "F", "G"]
```

✅ remove(at:)은 요소를 삭제하고 삭제한 요소를 리턴해줍니다</br>
그래서 배열에서 어떤 요소를 하나씩 꺼내서 작업하는 패턴을 구현할 때 'remove(at:)'을 자주 사용합니다.

'remove(at:)'에 잘못된 인덱스를 전달하게 되면 에러가 발생하게 되므로 조심해야 합니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%206.39.18.png?raw=true)

특정 위치에 있는 요소를 삭제한다면 'remove(at:)'을 사용하면 됩니다.

첫 번째 요소나 마지막 요소를 삭제할 경우에는 'removeFirst()', 'removeLast()'를 사용하면 됩니다.

'removeFirst()'를 보면 두 가지 형태가 있습니다.

먼저 파라미터 없이 호출할 경우에 대해서 알아보겠습니다.
```swift!
alphabet.removeFirst() // "A"
alphabet // [B", "D", "E", "F", "G"]
```
첫 번째 요소 하나를 삭제한 다음, 삭제한 것을 리턴해줍니다.
'remove(at: 0)'과 똑같은 결과를 가져옵니다.

그 다음 숫자를 파라미터로 전달하는 'removeFirst()'에 대해서 알아보겠습니다.
```swift!
alphabet.removeFirst(2) // ["E", "F", "G"]
alphabet // ["E", "F", "G"]
```
전달한 파라미터의 숫자만큼 삭제하는 것을 뜻합니다.
**이때는 삭제된 요소를 리턴하지 않습니다.**

**'removeLast()'는 'removeFirst()'와 뒤에서 부터 요소가 삭제된다는 점 외에는 모두 같습니다.**

배열에 저장된 모든 요소를 삭제하고 싶을 경우에는 'removeAll()'을 사용합니다.
```swift!
alphabet.removeAll() // []
```

**배열이 비어있는 상태에서 또 배열을 지우라는 메서드를 사용할 경우 에러가 발생합니다.**
```swift!
alphabet.removeAll() // []
alphabet.removeFirst() // error!!
```

**요소를 삭제할 때는 인덱스를 확인하는 것도 중요하지만 배열이 비어있는지 확인하는 것도 중요합니다.**

이번에는 'popLast()' 메서드에 대해 알아보겠습니다.

이 메서드는 'removeLast()' 메서드처럼 마지막 요소를 삭제하고 리턴해주는 기능입니다.

**popLast()의 리턴 타입을 보면 옵셔널임을 알 수 있습니다.**
즉, 배열이 비어있는 상태에서 'popLast()'를 호출할 경우 'nil'을 리턴합니다.

```swift!
alphabet.removeAll() // []
alphabet.popLast() // nil
```
**'popLast()'는 배열이 비어있을 때에도 아무런 문제 없이 사용할 수 있습니다.**
그러므로 조금 더 안전한 코드를 작성할 수 있습니다.

```swift!
var alphabet = ["A", "B", "C", "D", "E", "F", "G"]
alphabet.popLast() // "G"
alphabet // ["A", "B", "C", "D", "E", "F"]
```
위의 코드를 보면 'popLast()'를 실행시 마지막 요소인 "G" 가 리턴되는 것을 볼 수 있습니다.
배열에서는 "G"가 삭제되었음을 확인할 수 있습니다.

이번에는 범위를 지정한 다음 삭제해보겠습니다.

범위를 지정할 때는 'removeSubrange()' 메서드를 사용합니다.

'removeSubrange()'를 호출하고 삭제할 범위를 전달하면 됩니다.

```swift!
alphabet.removeSubrange(0...2) // ["D", "E", "F"]
alphabet // ["D", "E", "F"]
```

위 코드를 보면 지정한 범위가 삭제 된 것을 볼 수 있습니다.

'Subscript'문법을 사용하여 삭제도 가능합니다.
```swift!
alphabet[0...2] = [] // ArraySlice([])
alphabet // []
```

위와 같은 방법으로 삭제가 가능합니다.

이번에는 조금 다른 방법을 공부해보겠습니다.

**'drop'으로 시작하는 메서드는 원본 배열을 삭제하지 않습니다.**
**대신 원본 배열을 복사하여 새로운 배열을 만듭니다.**
**복사한 배열에서 삭제한 다음 삭제한 요소는 버리고 남은 배열을 리턴해줍니다.**
**동작 방식이 완전히 다른 것을 알 수 있습니다.**

먼저 'dropFirst()'부터 알아보겠습니다.
```swift!
var alphabet = ["A", "B", "C", "D", "E", "F", "G"]
alphabet.dropFirst() // ["B", "C", "D", "E", "F", "G"]
alphabet.dropFirst(3) // ["D", "E", "F", "G"]
alphabet // ["A", "B", "C", "D", "E", "F", "G"]
```

파라미터 없이 dropFirst를 호출하면 첫 번째 요소만 빼고 나머지를 배열로 리턴합니다.
파라미터를 전달하면 전달한 숫자만큼 요소를 삭제한 다음에 나머지를 배열로 리턴해줍니다.
그리고 원본을 보게되면 아무런 변화가 없는 것을 알 수 있습니다.

'dropLast()'의 경우 'dropFirst()'와 반대로 뒤에서 삭제합니다.
그것만 빼고 동작은 같습니다.

이번에는 'drop(while:)'에 대해서 알아보겠습니다.

**while**이 들어가는 것은 항상 조건입니다.
클로저에서 리턴하는 값이 true일 때 계속 drop 하는 것 입니다.

다음 코드를 보면 요소가 "C" 가 아닐때 계속 drop하다가, 다시말해 삭제하다가 요소가 "C"와 같으면 drop을 멈춥니다.
그리곤 남아있는 요소를 배열로 리턴해줍니다.

```swift!
let result = alphabet.drop { $0 != "C" }
result // ["C", "D", "E", "F", "G"]
```

그래서 결과를 보면 "A", "B"를 뺀 나머지가 ["C", "D", "E", "F", "G"] 배열로 리턴되는 것을 볼 수 있습니다.
