# Hello Toolchain ! (2)

오늘은 두 번째 친구 **컴파일러(Compiler)** 를 만나러 떠나 봅시다!!

렛츠~~ 고우우우웅 😆

## 🙋‍♂️ Hello Compiler !

**컴파일러(Compiler)** 는 고수준 프로그래밍 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 저수준의 기계어 코드나 중간 코드로 변환하는 소프트웨어 프로그램입니다.

이 변환 과정을 **'컴파일'** 이라고 합니다.

> ✅**컴파일(Compilation).**
> 
> **컴파일(Compilation)** 은 소스 코드를 기계가 이해할 수 있는 저수준의 언어(기계어 코드, 바이트코드 등)로 변환하는 과정을 의미합니다.
> 
> 이 과정은 컴파일러라고 하는 특수한 소프트웨어 프로그램에 의해 수행됩니다.
> 
> 컴파일러의 주요 목적은 사람이 이해하고 작성하기 쉬운 고수준 언어로 코딩된 프로그램을 컴퓨터가 실행할 수 있는 형태로 변환하는 것입니다.
> 
> **컴파일 과정은 대체로 다음과 같은 단계를 포함합니다.**
> 
> > **1. 구문 분석.**
> > 이 단계에서는 컴파일러는 소스 코드를 읽고, 코드를 가장 기본적인 요소인 '토큰'으로 분해합니다.
> > 토큰은 프로그래밍 언어의 가장 작은 단위로, 키워드, 식별자, 리터럴, 연산자 등이 될 수 있습니다.
> > 
> > **2. 구문 트리 생성.**
> > 구문 분석 단계에서 생성된 토큰들을 사용하여 프로그램의 구문적 구조를 나타내는 **'추상 구문 트리(Abstract Syntax Tree, AST')** 를 생성합니다.
> > 이 단계에서는 토큰들의 배열이 문법적으로 유효한지 확인하고, 코드의 구조를 나타내는 트리를 구성합니다.
> > 
> > **3. 의미 분석.**
> > AST를 검사하여 의미적으로 올바른지 확인하고, 타입 체크 등의 의미 분석을 수행합니다.
> > 
> > **4. 중간 코드 생성.**
> > 컴파일러는 AST를 바탕으로 하드웨어에 독립적인 중간 코드를 생성합니다.
> > 
> > **5. 최적화.**
> > 중간 코드를 최적화하여 실행 속도를 향상시키고 메모리 사용을 줄입니다.
> > 
> > **6. 코드 생성.**
> > 최적화된 중간 코드를 대상 플랫폼의 기계어 코드로 변환합니다.
> > 
> > **7. 링킹.**
> > 여러 개의 컴파일된 코드 파일(오브젝트 파일)과 외부 라이브러리를 링크하여 최종 실행 파일을 생성합니다.
> > 
> **컴파일 마무리**
> 
> 컴파일된 프로그램은 실행하기 전에 컴파일이 완료되어야 하며(정적인 시간에 컴파일), 일반적으로 이 과정은 프로그램의 실행보다 앞서 일어납니다.
> 
> 반면에, 인터프리터(Interpreter)는 프로그램을 한 줄씩 읽고 즉시 실행하는 방식으로 동작하여, 별도의 컴파일 과정 없이 소스 코드를 실행합니다.

> ✅ **중간 코드(Intermediate Code).**
> 
> **중간 코드(Intermediate Code)** 는 컴파일 과정에서 소스 코드를 기계어 코드로 변환하기 전에 생성되는, 하드웨어에 독립적인 코드 형태입니다.
> 
> **중간 코드는 보통 두 가지 주요 목적으로 사용됩니다.**
> 
> > **1. 플랫폼 독립성.**
> > 
> > 중간 코드는 특정 프로세서나 하드웨어에 의존하지 않기 때문에, 다양한 아키텍처에서 실행될 수 있는 프로그램을 만들기 위한 기반을 제공합니다.
> > 개발자는 하나의 소스 코드로부터 중간 코드를 생성하고, 이를 다양한 타겟 시스템에 맞게 더 낮은 수준의 기계어 코드로 변환할 수 있습니다.
> > 
> > **2. 최적화.**
> > 
> > 중간 코드는 최적화 과정에서 중요한 역할을 합니다.
> > 컴파일러는 중간 코드를 분석하여 성능을 향상시킬 수 있는 변환을 적용할 수 있습니다.
> > 이 최적화는 코드의 실행 시간을 단축하거나 메모리 사용을 감소시키는 등의 효과가 있습니다.
> > 
> **중간 코드는 여러 형식으로 표현될 수 있습니다.**
> > 
> > - **바이트코드(Bytecode) :** Java Virtual Machine(JVM)이나 .NET Common Language Runtime(CLR)과 같은 가상 머신 환경에서 사용되는 코드입니다.
> > 바이트코드는 가상 머신에 의해 해석되거나 Just-In-Time(JIT) 컴파일을 통해 기계어 코드로 변환될 수 있습니다.
> > 
> > - **삼중 주소 코드(Three-Address Code) :** 각 명령이 최대 세 개의 주소를 가질 수 있는 형태로, 중간 수준 언어의 명령 구조를 단순화합니다.
> > 
> > - **추상 구문 트리(Abstract Syntax Tree, AST) :** 소스 코드의 구문 구조를 나타내는 트리 형태의 데이터 구조로, 컴파일러 디자인에서 널리 사용됩니다.
> > 
> **중간 코드 마무리.**
> 
> 중간 코드는 컴파일러의 설계와 관련된 중요한 개념으로, 컴파일러가 어떻게 다양한 최적화를 수행하고 다양한 타겟 플랫폼을 지원하는지를 이해하는 데 도움을 줍니다. 


**컴파일러의 기본적인 역할과 프로세스는 다음과 같습니다.**

### 1. 구문 분석(Lexical Analysis).

컴파일러는 소스 코드를 토큰(token)이라는 기본 요소로 분해합니다.

토큰(token)은 변수 이름, 연산자, 숫자 등 소스 코드의 기본 구성 요소입니다.

> ✅ **토큰(Token)**
> 
> **토큰(Token)** 은 컴파일 과정에서 소스 코드를 해석할 때 사용하는 기본 단위입니다.
> 
> 컴파일러가 소스 코드를 읽을 때 **구문 분석(Lexical Analysis)** 단계에서는 코드를 여러 개의 토큰으로 분해합니다.
> 
> 이러한 토큰들은 프로그래밍 언어의 문법에 정의된 유효한 요소들로, 소스 코드를 구성하는 개별적인 단어와 기호들입니다.
> 
> **토큰의 예시로는 다음과 같은 것들이 있습니다.**
> 
> > **1. 키워드(Keyword) :** **`if`**, **`while`**, **`return`** 등과 같이 프로그래밍 언어가 문법적인 구조를 위해 예약한 단어들입니다.
> > 
> > **2. 식별자(Identifiers) :** 변수, 함수, 클래스 이름과 같은 사용자가 정의한 이름들입니다.
> > 
> > **3. 연산자(Operators) :** **'+'**, **'-'**, **'*'**, **'/'** 등과 같은 연산을 수행하는 기호들입니다.
> > 
> > **4. 리터럴(Literals) :** 숫자 값, 문자열 값과 같이 코드 내에서 직접 표현된 데이터 값입니다.
> > 
> > **5. 구분자(Delimiters) :** 코드의 시작과 끝, 구문의 분리를 나타내는 기호들, 예를 들어, 세미콜론(`;`), 괄호(`()`, `{}`, `[]`) 등이 있습니다.
> > 
> **토큰 마무리**
> 
> 토큰화 과정은 프로그래밍 언어의 문법 규칙에 따라 소스 코드 내의 문자열을 의미 있는 코드의 '단어'로 나누는 작업입니다.
> 
> 이 과정을 통해 컴파일러는 '추상 구문 트리(Abstract Syntax Tree, AST)'와 같은 더 높은 수준의 구문 구조를 생성할 준비를 합니다.
> 
> 토큰은 컴파일러가 코드를 올바르게 이해하고 구조화하는 데 필수적인 역할을 합니다.

### 2. 구문 트리 생성(Syntax Ananlysis).

토큰들을 구조화하여 추상 구문 트리(Abstract Syntax Tree, AST)를 생성합니다.

이 트리는 프로그램의 구조적 표현을 나타냅니다.

> ✅ **추상 구문 트리(Abstract Syntax Tree, AST)**
> 
> **추상 구문 트리(Abstract Syntax Tree, AST)** 는 프로그래밍 언어의 소스 코드의 구조를 나타내는 트리형 데이터 구조입니다.
> 
> 컴파일러 또는 인터프리터가 소스 코드를 분석할 때 생성되며, 코드의 문법적 구조를 명확하게 표현합니다.
> 
> 각 노드는 프로그래밍 언어의 구성 요소(예: 연산자, 키워드, 식별자 등)를 나타냅니다.
> 
> 노드 사이의 연결은 어떻게 이러한 구성 요소들이 서로 관련되어 있는지를 나태냅니다.
> 
> 예를 들어, 산술 표현식 **`3 + (4 * 5)`** 의 AST에서는 더하기 연산자가 루트 노드가 되고, 자식 노드로 숫자 3과 곱하기 연산을 나타내는 노드가 연결됩니다.
> 
> **AST는 다음과 같은 프로그래밍 언어 처리 과정에서 중요한 역할을 합니다.**
> 
> > **1. 의미 분석 :** AST를 통해 컴파일러는 변수의 스코프, 타입 체크, 식별자의 사용과 같은 의미적 유효성을 검사합니다.
> > 
> > **2. 코드 최적화 :** 최적화 단계에서 컴파일러는 AST를 사용하여 코드를 보다 효율적으로 만들 수 있는 방법을 찾습니다.
> > 
> > **3. 중간 코드 생성 :** AST는 컴파일러가 중간 코드나 최종 목적 코드를 생성하기 위한 기반으로 사용됩니다.
> > 
> > **4. 오류 메시지 생성 :** 소스 코드에 오류가 있을 경우, AST를 기반으로 사용자에게 보다 정확하고 유용한 오류 메시지를 제공할 수 있습니다.
> **AST 마무리.**
> 
> AST는 프로그래밍 언어의 구문과 구조를 이해하고, 효과적인 코드 변환과 최적화를 수행하는 데 있어 필수적인 컴파일러의 구성 요소입니다.

### 3. 의미 분석(Semantic Analysis).

구문 트리를 검사하여 의미상의 오류를 찾아냅니다.

변수의 유효 범위, 타입 체크, 표현식의 유효성 등을 검사합니다.

### 4. 중간 코드 생성(Intermediate Code Genneration).

소스 코드의 높은 추상 수준을 낮은 수준의 중간 표현으로 변환합니다.

이 중간 표현은 특정 하드웨어 독립적입니다.

### 5. 최적화(Code Optimization).

컴파일러는 중간 코드를 분석하여 불필요한 코드를 제거하고 성능을 향상시키기 위한 최적화를 수행합니다.

### 6. 기계어 코드 생성(Code Generation).

최적화된 중간 코드를 특정 하드웨어 아키텍처가 이해할 수 있는 기계어 코드로 변환합니다.

### 7. 링킹(Linking).

여러 코드 모듈과 라이브러리를 링크하여 실행 가능한 파일을 만듭니다.

링커(Linker)는 컴파일러에 포함되어 있어가 별도의 도구로 제공될 수 있습니다.

> ✅ **링킹, 링크, 링커**
> 
> **링킹, 링크, 링커** 는 프로그래밍과 소프트웨어 개발에서 사용되는 용어들로, 컴파일 과정의 마지막 단계와 관련이 있습니다.
> 
> 이들 용어는 컴파일된 코드를 최종 실행 파일로 만드는 과정을 설명합나다.
> 
> **링킹(Linking)**
> > 링킹은 컴파일러가 생성한 하나 이상의 오브젝트 파일(object file)과 라이브러리들을 결합하여 실행 가능한 파일이나 라이브러리를 생성하는 과정입니다.
> > 
> > **링킹은 일반적으로 다음 두 가지 유형으로 나눌 수 있습니다.**
> > 
> > - **정적 링킹(Static Linking) :** 필요한 모든 코드를 포함하는 단일 실행 파일을 생성합니다. 이는 필요한 라이브러리의 코드를 최종 실행 파일 안에 포함시키는 것을 의미합니다.
> > 
> > - **동적 링킹(Dynaic Linking) :** 실행 시간에 필요한 라이브러리를 참조하는 실행 파일을 생성합니다. 실제 라이브러리 코드는 별도의 파일(동적 링크 라이브러리, DLLs)로 존재하며, 프로그램 실행 중에 로드됩니다.
> > 
> **링크(Link)**
> 
> > 링크는 링킹 과정에서 실제로 수행되는 연결 작업을 의미합니다.
> > 이는 다양한 코드 섹션들을 서로 연결하고, 외부 참조를 해결하는 과정을 포함합니다.
> > 예를 들어, 함수 호출이나 전역 변수의 링크 단계에서 해당 코드의 실제 주소로 연결됩니다.
> 
>  **링커(Linker)**
>  
> > 링커는 링킹(Linking)과정을 수행하는 소프트웨어 도구입니다.
> > 링커(Linker)는 오브젝트 파일들과 라이브러리들을 취하여 심볼 해석(symbol resolution) 및 재배치(relocation)를 수행하고, 이를 하나의 실행 파일로 결합합니다.
> > 링커는 컴파일러나 IDE에 포함되어 있거나, 독립된 도구로 존재할 수 있습니다.
> > 
> **링커의 주요 작업은 다음과 같습니다.**
> > - **심볼 해석 :** 프로그램 내부의 심볼(함수, 변수 등의 이름)을 해당 심볼의 실제 메모리 주소나 코드 위치로 매핑합니다.
> > 
> > - **재배치 :** 코드와 데이터 섹션들을 메모리의 적절한 위치에 맞게 조정합니다.
> > 
> > - **오류 해결 :** 링킹 과정에서 발견된 문제들(예: 미해결 심볼, 중복 정의 등)을 사용자에게 알립니다.
> > 
> **링커 마무리.**
> 
> 링커는 개발 과정의 필수적인 부분이며, 최종적으로 사용자가 실행할 수 있는 소프트웨어를 생성하는 데 중요한 역할을 합니다.

여기까지 컴파일러가 어떤건지 그리고 그 세부적인 사항들에 대해서 알아보았습니다.

그렇다면 Xcode에도 컴파일러가 있을겁니다.

Xcode에는 어떤 컴파일러가 있는지 알아봅시다 :)

## 🙋‍♂️ Hello Xcode Compiler !

Xcode는 Apple의 macOS 및 iOS 애플리케이션 개발을 위한 통합 개발 환경(IDE)으로, 여러 컴파일러를 지원합니다.

이를 통해 개발자는 Objective-C, Swift, C, C++ 등의 언어로 작성된 프로그램을 컴파일할 수 있습니다.

**Xcode 내에 포함된 주요 컴파일러는 타음과 같습니다.**

- 1. Swift 컴파일러(`swiftc`)
- 2. LLVM 컴파일러

Xcode의 컴파일러는 소스 코드의 구문 분석, 최적화, 코드 생성, 링킹 등의 작업을 수행합니다.

또한, Xcode는 인터페이스 디자인, 디버깅, 성능 분석 등의 다양한 개발 도구와 함께 제공되어, Apple 플랫폼에서의 앱 개발에 필요한 전반적인 기능을 지원합니다.

그렇다면 먼저 **Swift 컴파일러**에 대해서 알아봅시다.

## 1. Swift 컴파일러(`swiftc`)

**`swiftc`** 는 Swift 프로그래밍 언어를 위한 공식 컴파일러입니다.

Swift 언어는 Apple에 의해 개발되었으며, 주로 iOS, macOS, watchOS, tvOS 애플리케이션 개발에 사용됩니다.

`swiftc` 컴파일러는 이 언어의 소스 코드를 기계어로 변환하여 실행 가능한 프로그램이나 라이브러리를 생성합니다.

### `swiftc` 컴파일러의 주요 특징은 아래와 같습니다.

**1. Swift 언어 지원.**

**`swift`** 는 Swift 언어의 모든 기능을 지원하며, 언어의 최신 버전에 대한 업데이트를 지속적으로 받습니다.

**2. LLVM 기반.**

**`swiftc`** 는 LLVM 컴파일러 인프라에 기반을 두고 있으며, 이를 통해 강력한 최적화와 코드 생성 기능을 제공합니다.

**3. 효율적인 성능 최적화.**

**`swiftc`** 는 코드의 성능을 향상시키기 위한 다양한 최적화를 수행합니다.

이는 실행 시간을 단축하고 메모리 사용을 최적화하는 데 도움을 줍니다.

**4. 다양한 플랫폼 지원.**

컴파일된 Swift 코드는 iOS, macOS, watchOS, tvOS 등 여러 Apple 플랫폼에서 실행될 수 있으며, Linux와 같은 다른 운영 체제에서도 실행될 수 있습니다.

**5. 통합 개발 환경(IDE)과의 호환성.**

**`swiftc`** 는 Xcode와 같은 IDE와 긴밀하게 통합되어 있으며, Xcode에서 Swift 프로그래밍을 할 때 자동으로 사용됩니다.

**6. 명령줄 도구.**

**`swift`** 는 명령줄 인터페이스를 제공하며, 개발자는 터미널에서 직접 Swift 파일을 컴파일할 수 있습니다.

**7. 에러 메시지와 경고.**

**`swiftc`** 는 코드에 문제가 있을 경우 명확하고 이해하기 쉬운 에러 메시지와 경고를 제공하여, 개발자가 문제를 쉽게 식별하고 수정할 수 있도록 돕습니다.

## `swiftc` 컴파일러 마무리.

`swiftc` 컴파일러는 Swift 언어의 강력한 기능을 활용하여 높은 성능과 효율적인 메모리 관리를 제공하는 애플리케이션을 개발하는 데 핵심적인 역할을 합니다.

이번에는 

## 2. LLVM 컴파일러.

LLVM 컴파일러는 Xcode의 중요한 구성 요소로, LLVM(Project Low-Level Virtual Machine)컴파일러 인프라스트럭처를 기반으로 합니다.

LLVM은 고성능, 고수준 언어로의 이식성, 그리고 코드 최적화를 위해 설계된 컴파일러 기술 집합입니다.

Apple은 이를 Xcode 내에서 Objective-C, C, C++ 언어의 컴파일에 사용합니다.

### LLVM 컴파일러의 주요 특징.

**1. 모듈화 및 재사용 가능성.**

LLVM은 여러 개의 작은 라이브러리로 구성되어 있으며, 이를 통해 다양한 컴파일러 및 도구에서 재사용할 수 있습니다.

**2. 최적화.**

LLVM은 중간 표현(IR)을 사용하여 코드를 분석하고 최적화합니다.

이는 컴파일 시간과 실행 시간 모두에서 성능을 향상시키는 최적화를 수행할 수 있게 해줍니다.

**3. 플랫폼 간 이식성.**

LLVM의 중간 코드는 플랫폼에 독립적이어서, 다양한 하드웨어 아키텍처에서 컴파일된 프로그램을 실행할 수 있습니다.

**4. Just-In-Time(JIT) 컴파일.**

LLVM은 JIT 컴파일을 지원하여, 프로그램을 실행하는 도중에 필요한 부분만을 실시간으로 컴파일할 수 있습니다.

이는 런타임 최적화와 다이나믹 언어 지원에 유용합니다.

**5. 백엔드 지원.**

LLVM은 다양한 하드웨어 아키텍처에 대한 백엔드를 지원하여, 같은 소스 코드를 여러 플랫폼의 기계어로 컴파일할 수 있게 합니다.

**6. Clang 프론트엔트**

LLVM 프로젝트의 일부인 Clang 프론트엔드는 C, C++, Objective-C 언어를 위한 컴파일러 프론트엔트로, 사용자 친화적인 에러 메시지와 빠른 컴파일 속도를 제공합니다.

## LLVM 마무리.

LLVM 컴파일러는 Xcode에서 개발되는 Apple의 소프트웨어 제품에 높은 성능과 효율성을 제공합니다.

이를 통해 개발자는 다양한 Apple 플랫폼에서 최적화된 애플리케이션을 개발할 수 있습니다.

## 💪 컴파일러 마무리.

오늘은 컴파일러가 무엇인지 그리고 기본적인 역할과 어떤 프로세스를 거치는지를 알아보았으며, Xcode 에서의 컴파일러도 알아봤어요 히히

정말 많은 탐험을 했네요 :)

다음에는 또 어떤 모험이 기다리고 있을지 너무 설레입니다 헤헿

오늘은 여기까지 그럼 안뇨오오옹~
