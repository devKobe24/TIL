# Dictionary(1)
---

### 🙋‍♂️ Topic
- 1️⃣ **딕셔너리의 특징**
---

✏️ **딕셔너리의 특징**</br>
✅ **딕셔너리는 키(Key)와 값(Value)를 짝 지어서 하나의 요소로 저장합니다.**</br>

🔑 **키(Key)** : 하나의 딕셔너리 안에서 **유니크**한 값입니다.</br>
🔓 **값(Value)** : 하나의 딕셔너리 안에서 다른 값(Value)와 **같아도** 됩니다.</br>

값의 타입에는 제한이 없습니다.
값에는 아무것이나 사용이 가능합니다.

🙋‍♂️ **키(Key)** 의 경우 **Hash**를 구현한 타입만 사용해야합니다.
- Swift에서는 **Hashable** 프로토콜로 구현이 가능합니다.
    - 제대로 구현하지 않을 경우 성능에 나쁜 영향을 줄 수 있습니다. 😵

> 📓 문자열은 이미 **Hash**를 구현하고 있습니다.
> 따라서 문자열을 키 값으로 사용할 경우 복잡한 Hashing code를 구현하지 않아도 됩니다.

> 📓 **Hashable**
> ![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-28%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.52.39.png?raw=true)
>
> 정수 해시 값을 생성하기 위해 Hasher로 해시될 수 있는 타입입니다.
> 
> 세트 또는 딕셔너리의 키로 Hashable 프로토콜을 준수하는 모든 타입을 사용할 수 있습니다.
> 표준 라이브러리의 많은 타입은 Hashable을 준수합니다.
> String, Int, Float 그리고 Bool 심지어 Set도 기본적으로 해시 가능합니다.
> Optional, Array 및 Ranges와 같은 일부 다른 타입은 type argument가 동일하게 구현될 때 자동으로 해시 가능해집니다.
> 
> 커스텀 타입(사용자 정의 타입)도 해시 가능할 수 있습니다
> 연관된 값 없이 열거형을 정의하면 자동으로 Hashable 적합성을 얻게 되며 hash(into:) 메소드를 구현하여 다른 커스텀 타입(사용자 정의 타입)에 Hashable 적합성을 추가할 수 있습니다.
> 저장 프로퍼티가 모두 Hashable인 구조체와 모든 Hashable 연관 값이 있는 enum 타입의 경우 컴파일러는 자동으로 hash(into:) 구현을 제공할 수 있습니다.
> 
> 값을 해싱한다는 것은 값의 필수 구성 요소를 Hasher 타입으로 표시되는 해시 함수에 공급한는 것을 의미합니다.
> 필수 구성 요소는 타입의 Equatable 구현에 기여하는 구성 요소입니다.
> 동일한 두 인스턴스는 동일한 순서로 hash(into:)의 동일한 값을 Hasher에 공급해야 합니다.

> 📓 **Hashable(2)**
> Swift에서 Hashable 프로토콜은 특정 객체를 고유하게 식별할 수 있는 방법을 제공합니다.
> Hashable 프로토콜을 준수하는 타입은 그 인스턴스를 해시 가능하게 만들며, 이는 고유한 해시 값을 계산할 수 있음을 의미합니다.
> 이 해시 값은 hash(into:) 메서드를 사용하여 얻을 수 있습니다.
> 
> Hashable 프로토콜을 준수하면 해당 타입의 객체는 딕셔너리의 키나 세트의 값으로 사용할 수 있게 됩니다.
> 딕셔너리와 세트는 고유한 값을 유지하며 빠른 조회를 위해 해시 값에 의존합니다.
> 
> Hashable 프로토콜은 Equatable 프로토콜을 확장합니다.
> 따라서 Hashable 프로토콜을 준수하는 타입은 == 연산자를 통해 두 인스턴스를 비교할 수 있어야 합니다.
> 그리고 또한 hash(into:) 메서드를 구현해야 합니다.

> 📓 해시(Hash)?
> 해시(Hash)는 데이터를 특정 길이를 가진 고유한 값으로 변환하는 과정이라 그 결과를 가리키는 용어입니다.
> 이 변환과정은 일반적으로 해시 함수를 통해 이루어집니다.
> 해시 함수는 임의의 크기의 데이터를 입력 받아 고정된 크기의 데이터를 출력합니다.
>
> 해시의 중요한 특성 중 하나는 동일한 입력에 대해 항상 동일한 출력을 내놓는다는 것입니다.
> 즉, 어떤 데이터에 대한 해시 값을 한 번 계산한 후, 나중에 같은 데이터에 대해 다시 해시 값을 계산하면 처음에 계산한 값과 같아야 합니다.
>
> 또한, 해시 함수는 보통 원래의 입력을 복구할 수 없는 일방향성을 갖습니다.
> 즉, 해시 값만으로는 원래의 데이터를 알아내는 것이 불가능합니다.
> 이러한 특성 때문에 해시는 보안 분야에서 암호화, 데이터 무결성 확인등의 용도로 많이 사용됩니다.
> 
> 그러나 해시는 보안 외에도 많은 분야에서 사용됩니다.
> 예를 들어, 해시 값을 사용하여 데이터를 빠르게 검색하거나 저장하는 해시 테이블 같은 자료구조가 있습니다.
> 또한, 프로그래밍 언어의 딕셔너리나 맵 타입에서 키를 빠르게 찾는데 해시를 사용하기도 합니다.
> 이런 경우에는 입력 데이터(Key)를 해시 값으로 변환하여, 해당 Key에 연결된 값(Value)를 빠르게 찾습니다.

📱 iOS에서 자주 사용하는 **Key-Value Coding**이라는 기술이 있습니다.
이것을 딕셔너리를 이용하면 활용할 수 있다는 장점도 있습니다.

> 📓 **Key-Value Coding(KVC)?**
> Key-Value Coding(KVC)는 Apple의 Cocoa 프레임워크에서 사용하는 기술로, 객체의 속성에 문자열을 사용하여 동적으로 접근하거나 조작할 수 있게 해줍니다.
> 이 기능은 Objective-C 및 Swift에서 iOS 애플리케이션을 개발할 때 사용되는 중요한 도구 중 하나입니다.
>
> Key Value Coding을 사용하면, 코드가 실행 시점에서 객체의 특정 속성을 식별하고 접근할 수 있습니다.
> 이것은 런타임에서 객체의 상태를 유연하게 관리하고 변경하거나, 프로그램 내부에서 동적으로 데이터를 처리할 수 있음을 의미합니다.
> 예를 들어 Swift에서 객체의 속성에 접근하기 위해 일반적으로 다음과 같이 접근할 것입니다.
> ```swift!
> let name = person.name
> ```
> 하지만 Key Value Coding을 사용하면, 다음과 같이 접근할 수 있습니다.
> ```swift!
> let name = person.value(forKey: "name")
> ```
> 여기서 "name"은 속성 이름을 나타내는 문자열입니다.
> 이런 방식은 코드를 보다 유연하게 만들어 줄 수 있습니다.
> 예를 들어, 어떤 특정 속성의 이름을 런타임에서만 알 수 있는 경우에도 해당 속성에 접근하거나 수정 할 수 있습니다.
> 
> KVC는 프레임워크의 다른 부분과 상호작용하는 데도 사용되며, 예를 들어 Key-Value Observing(KVO), Core Data, Cocoa bindings 등에서 볼 수 있습니다.
>
> 그러나 주의할 점은 KVC는 타입 안전성을 보장하지 않습니다.
> 즉, 컴파일러가 타입 불일치에 대해 미리 경고해주지 않고, 잘못된 키를 사용하면 런타임 오류가 발생할 수 있다는 것입니다.
> 따라서 사용에 주의가 필요합니다.

> 📓 **동적으로 접근한다**
> "동적으로 접근한다"는 말은 코드가 실행되는 시점(runtime)에 특정 작업을 수행한다는 것을 의미합니다.
> 이것은 프로그램이 실행되는 동안 객체의 속성이나 메서드에 접근하거나 변경하는 것을 포함합니다.

> 📓 **정적으로 접근한다**
> "정적으로 접근한다"는 말은 "동적으로 접근한다"는 말과 대조적인 개념입니다.
> 정적인 접근 방식에서는 코드가 컴파일 시점에 정해집니다.
> 즉, 속성이나 메서드의 이름이 코드에 직접 작성이 되어 있고, 해당 요소에 접근하거나 변경하는 동작도 미리 결정됩니다.

✅ **정렬되지 않는 컬랙션(Unordered Collection)**</br>

딕셔너리에 저장되는 요소는 정렬이 되지 않습니다.
딕셔너리에도 인덱스가 있고, 정렬 메서드가 있으니 정렬이 된다고 생각하는 경우가 종종 있습니다.
딕셔너리는 "정렬되지 않습니다."

🙋‍♂️ **딕셔너리는 정렬되지 않는 컬랙션입니다.**</br>
🙌 만약에 정렬이 필요하다면 Swift Collection Package에 있는 **Ordered Dictionary**라는 것을 사용하면 됩니다.</br>
🙌 또는 키(Key) 목록을 배열(Array)로 바꿔서 정렬한 다음 사용해야 합니다.

✅ **Single Type**</br>

딕셔너리에는 하나의 타입만 저장할 수 있습니다.
다시 말해 키(Key)의 타입이 모두 같아야하며, 값(Value)의 타입도 모두 같아야 합니다.

하지만 키(Key)와 값(Value)의 타입은 서로 달라도 됩니다.
