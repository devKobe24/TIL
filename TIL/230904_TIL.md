# 추상 팩토리(Abstract Factory) 🧩

---

### 의도

**상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다.**

### 다른 이름

**키트(Kit)**

### 동기

**✅ 모티프와 프레젠테이션 매니저와 같은 사용자 인터페이스 툴킷을 살펴보면, 서로 다른 룩앤필 표준을 가지고 있습니다.**
- 모티프(Motif): 그래픽 디자인, 패턴, 아이콘 등을 의미하는 단어입니다.
- 프레젠테이션 매니저 : 프레젠테이션 소프트웨어를 관리하거나 사용하는 역할을 나타냅니다.
    - 프레젠테이션 소프트웨어 : 사용자가 아이디어, 정보, 데이터 등을 시각적으로 구성하고 전달할 수 있는 도구입니다.</br>- 1 ) 이 소프트웨어를 사용하면 슬라이드를 만들고 편집하여 텍스트, 이미지, 도표, 그래픽 등을 조합하여 프로페셔널한 프레젠테이션을 만들 수 있습니다.</br> - 2 ) 대표적인 프레젠테이션 소프트웨어로는 MSOffice의 Power point, Google의 슬라이드, Apple의 Keynote 등이 있습니다.</br>- 3 ) 이러한 소프트웨어들은 비즈니스, 교육, 기술 발표 등 다양한 분야에서 활용되며, 시각적인 요소와 효과를 시용하여 내용을 효과적으로 전달하는 데 도움을 줍니다.</br>

**✅ 서로 다른 룩앤필은 서로 다른 사용자 인터페이스의 표현 방식과 행동을 갖습니다.**
- 스크롤바, 윈도우 버튼은 모양이 다르고 동작 방식도 서로 다릅니다.</br>

**✅ 개발한 응용프로그램이 서로 다른 룩앤필 표준에 상관없이 이식성을 가지려면, 응용프로그램이 각 사용자 인터페이스 둘킷에서 제공하는 위젯을 직접 사용하지 못하도록 해야 합니다.**
- 위젯 : 사용자의 디바이스나 웹 페이지에 삽입되어 다양한 정보나 기능을 제공하는 작은 애플리케이션 또는 컴포넌트를 말합니다.
    - 위젯은 주로 홈 화면, 작업 표시줄, 웹 사이트의 사이드바 등에 배치하여 사용자가 편리하게 정보나 기능을 접근하고 사용할 수 있게 도와줍니다.
    - 위젯은 다양한 형식과 크기로 제공되며, 날씨 정보, 뉴스 헤드라인, 시간 달력, 검색 상자 등 다양한 종류의 콘텐츠를 보여주거나 상호작용할 수 있는 버튼, 링크, 입력 필드 등을 포함할 수 있습니다.
    - 위젯은 디바이스나 웹 페이지의 디자인을 더 풍부하게 만들고 사용자 경험을 개선하는 데 사용됩니다.</br>

**✅ 이런 문제는 구체적 사용자 인터페이스의 위젯을 사용하지 말고 추상 클래스인 `WidgetFactory`를 정의하여 해결하는게 좋습니다.**
- `WidgetFactory` 클래스는 위젯의 기본 사용자 인터페이스 요소(윈도우, 스크롤바, 버튼 등)를 생성할 수 있는 인터페이스를 정의합니다.
- 그리고 응용프로그램은 필요한 사용자 인터페이스 요소를 `WidgetFactory`에 생성해 줄 것을 요청하여, 필요한 요소의 인스턴스를 얻어옵니다.
    - **✅ 물론, 실제적으로 구현 종속적인 인스턴스를 생성하기 위해서는 팩토리와 구분하여 각각의 위젯별로 추상화된 클래스를 정의해야 하고, 이를 상속하는 주체적인 서브클래스를 정의하여 구체적 룩앤필 표준에 대한 구현을 제공합니다.**</br>

**✅ 예를 들어, `Window`라는 개념의 사용자 인터페이스가 있다면 인스턴스를 생성하는 팩토리와 구분하여 생성할 룩앤필의 표준에 대응하는 `Window` 클래스를 추상 클래스로 정의합니다.**</br>

**✅ 그리고 나서 각 사용자 인터페이스 툴킷이 제공하는 위젯 및 구현 방식에 따라 `PMWindow`, `MotifWindow`를 정의합니다.**</br>

**✅ `WidgetFactory` 인터페이스는 각 추상화된 위젯 클래스의 인스턴스를 생성하여 반환하는 연산을 정의합니다.**
- 사용자는 `WidgetFactory`에 원하는 요소의 인스턴스를 생성하는 연산을 호출하여 위젯의 인스턴스를 얻게 됩니다.
- 그러나 사용자는 `WidgetFactory`를 상속받은 어떤 구체적 서브클래스가 이들 연산을 구현하여 결과를 반환하는지 알 수 없고, 알 필요도 없습니다.
    - **✅ 즉, 사용자는 팩토리에만 메시지를 보낼 뿐이지, `PMWindow`에 메시지를 보내는지, `MotifWindow`에 보내는지 알 필요가 없습니다.</br>🙌 이로써 사용자는 룩앤필과 분리될 수 있습니다.**</br>

**✅ 이 패턴을 사용하기 위해서는 `AbstractFactory`에 해당하는 `WidgetFactory`뿐만 아니라 각 룩앤필 표준에 대한 `WidgetFactory`를 상속받는 구체 서브클래스들을 정의해야 합니다.**</br>
- 아래 그림에 정의된 모델을 보면 `WidgetFactory` 및 이 클래스의 서브클래스들과 이들이 생성하는 위젯 클래스 간의 모델이 표현되어 있습니다.</br>

**✅ `WidgetFactory`를 상속받는 서브클래스들인 `MotifWidgetFactory`와 `PMWidgetFactory`가 구체적 룩앤필에 정의된 실제 위젯을 생성하는 연산을 구현합니다.**</br>
- 즉, `MotifWidgetFactory`에 정의된 `CreateScrollBar` 연산은 모티프의 스크롤바를 반환하고, `PMWidgetFactory`에 있는 해당 연산은 프레젠테인션 매니저에 필요한 스크롤바를 생성해서 반환합니다.</br>
    - **✅ 그러나 사용자는 이런 내부 처리와 상관없이, `WidgetFactory` 인터페이스를 통해서만 추상화된 위젯을 생성합니다.**</br>

**✅ `WidgetFactory`를 사용하면 구체 위젯 클래스 사이에 의존 관계가 만들어집니다.**
- 모티프의 스크롤바는 모티프 버튼 및 모티프 텍스트 편집기와 함께 사용되어야 하는것이죠. `MotifWidgetFactory`를 쓴 결과로 자동으로 생긴 제약입니다.

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5.png?raw=true"></br>

## 활용성

**✅ 추상 팩토리는 다음의 경우에 사용합니다.**

- 객체가 생성되거나 구성.표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 여러 제품군 중 하나를 선택해서 시스템을 설정해야 하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때
- 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을 때
- 제춤에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

## 구조

<img src = "https://github.com/devKobe24/images/blob/main/%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9.png?raw=true"></br>

## 참여자

- **AbstractFactory(WidgetFactoru) :</br>개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의합니다.**
- **ConcreteFactory(MotifWidgetFactory, PMWidgetFactory) :</br>구체적인 제품에 대한 객체를 생성하는 연산을 구현합니다.**
- **AbstractProduct(Window,ScrollBar) :</br>개념적 제춤 객체에 대한 인터페이스를 정의합니다.**
- **ConcreteProductProduct(MotifWindow, MotifScrollBar) :</br>구체적으로 팩토리가 생성할 객체를 정의하고, `AbstractProduct`가 정의하는 인터페이스를 구현합니다.**
- **Client: `AbstractFactory`와 `AbstractProduct` 클래스에 선언된 인터페이스를 사용합니다.**

## 협력 방법

- 일반적으로 `ConcreteFactory` 클래스의 인스턴스 한 개가 런타임에 만들어집니다.</br>이 구체 팩토리(concrete factory)눈 어떤 특정 구현을 갖는 제품 객체를 생성합니다.</br> 새로 다른 제품 객체를 생성하려면 사용자는 서로 다른 구체 팩토리를 사용해야 합니다.
- `AbstractFactory`는 필요한 제품 객체를 생성하는 책임을 `ConcreteFactory` 서브 클래스에 위임합니다.

## 결과

**✅ 추상 팩토리 패턴을 쓰면서 얻는 이익과 부담은 다음과 같습니다.**</br>

- 1. **구체적인 클래스를 분리합니다.**
    - 추상 팩토리 패턴을 쓰면 응용프로그램이 생성할 객체의 클래스를 제어할 수 있습니다.
    - 팩토리는 제품 객체를 생성하는 과정과 책임을 캡슐화한 것이기 때문에, 구체적인 구현 클래스가 사용자에게서 분리됩니다.
    - 일반 프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작합니다.
    - 제품 클래스 이름이 구체 팩토리의 구현에서 분리되므로, 사용자 코드에는 나타나지 않는 것입니다.

- 2. **제품군을 쉽게 대체할 수 있도록 합니다.**
    - 구체 팩토리 클래스는 응용프로그램에서 한 번만 나타니기 때문에 응용 프로그래밍 사용할 구체 팩토리를 변경하기는 쉽습니다.
    - 또한, 구체 팩토리를 변경함으로써 응용프로그램은 서로 다른 제품을 사용할 수 있게 변경됩니다.
    - 추상 팩토리는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한번에 변경이 가능합니다.
    - 위에서 보신 사용자 인터페이스 예제에서 Motif 위젯을 PM 위젯으로 쉽게 변경할 수 있었는데, 이는 대응하는 팩토리를 교체하고 이 인터페이스를 다시 만들어서 해결한 것입니다.

- 3. **제품 사이의 일관성을 증진시킵니다.**
    - 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한 번에 오직 한 군에서 만들 객체를 사용하도록 함으로써 프로그램의 일관성을 갖도록 해야 합니다.
    - 추상 팩토리를 쓰면 이 점을 아주 쉽게 보장할 수 있습니다.

- 4. **새로운 종류의 제품을 제공하기 어렵습니다.**
    - 새로운 종류의 제품을 만들기 위해 기존 추상 팩토리를 확장하기가 쉽지 않습니다.
    - 생성되는 제품은 추상 팩토리가 생성할 수 있는 제품 집합에만 고정되어 있기 때문입니다.
    - 만약 새로운 종류의 제품이 등장하면 팩토리의 구현을 변경해야 합니다.
    - 이는 추상 팩토리와 모든 서브클래스의 변경을 가져옵니다.
    - 즉, 인터페이스가 변경되는 새로운 제품을 생성하는 연산이 추가되거나, 기존 연산의 반환 객체 타입이 변경되었으므로, 이를 상속받는 서브클래스 모두 변경되어야 합니다.
