# print("Hello world!") (1)

ìš°ë¦¬ê°€ í”„ë¡œê·¸ë˜ë°ì„ ì‹œì‘í•˜ë©´ ì œì¼ ë¨¼ì € ë§Œë‚˜ëŠ” ì¹œêµ¬ê°€ ë°”ë¡œ **`print("Hello world!")`** 

ë‚˜ëŠ” ì´ **`print("Hello world!")`** ê°€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ ë„ˆë¬´ ê¶ê¸ˆí•´ì ¸ì„œ ë‚´ë¶€ë¥¼ ë“¤ì—¬ë‹¤ë³´ê¸°ë¡œ í–ˆë‹¤.

(ë„ˆëŠ” ë‚˜ì—ê²Œ ì¸ì‚¬ë¥¼ ê±´ëƒˆì§€ë§Œ ë‚˜ëŠ” ë„ˆì˜ ì†ì„ ë´ì•¼ê² ì–´ ğŸ˜†)

<img src = "https://github.com/devKobe24/images/blob/main/%5Bstdlib:test:Print%5D.png?raw=true">

ê·¸ë˜ì„œ ë“¤ì—¬ë‹¤ ë³¸ **`stdlib/test/Print.swift`** ë‚´ë¶€ì˜ ëª¨ìŠµ.

ì¼ë‹¨ í…ŒìŠ¤íŠ¸ íŒŒì¼ì´ë‹¤ ë³´ë‹ˆ '**`Print`** ë¥¼ í…ŒìŠ¤íŠ¸ í•œ ê²ƒì´ê² êµ¬ë‚˜.' í•˜ê³¤ ìƒê°í–ˆë‹¤.

ê·¸ë ‡ë‹¤ë©´ 'ì € ìœ„ì— **`import`** ëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë” ë“¤ì—¬ë‹¤ ë´ì•¼ê² ë‹¤' ë¼ê³  ìƒê°í•˜ê³  ë” ë“¤ì–´ê°€ ë´¤ë‹¤.

ê°€ì¥ ë¨¼ì € ë“¤ì–´ê°€ ë³¸ ê³³ì€ **`PrintTestTypes`** ì˜€ë‹¤.

<img src = "https://github.com/devKobe24/images/blob/main/%5Btest:stdlib:inputs:PrintTestTypes.swift%5D.png?raw=true">

ê°€ì¥ ì²« ì¤„ ë¶€í„° ì²œì²œíˆ ì½ì–´ ë‚´ë ¤ê°€ë´¤ë‹¤.

ê°€ì¥ ì²« ì¤„ì˜ ì½”ë“œëŠ” 

```swift
public protocol ProtocolUnrelatedToPrinting {}
```

ì¼ë‹¨ ë¹ˆ `public protocol`ì„ ë§Œë“¤ì–´ ë†“ì•˜ë‹¤.

ê°€ì¥ ë¨¼ì € ë– ì˜¤ë¥¸ ìƒê°ì€ **'ì™œ?'** ì˜€ë‹¤.

ê·¸ë˜ì„œ **í”„ë¡œí† ì½œ(protocol)** ì— ëŒ€í•´ì„œ ë‹¤ì‹œê¸ˆ ìƒê°í•´ ë³´ë©° ì±…ì„ ë’¤ì ¸ë´¤ë‹¤.

[ìŠ¤ìœ„í”„íŠ¸ í”„ë¡œê·¸ë˜ë°: Swift 5](https://product.kyobobook.co.kr/detail/S000001810190)ì—ì„œ **'í”„ë¡œí† ì½œì´ë€?'** í•­ëª©ì„ ë‹¤ì‹œ ì‚´í´ë³´ë‹ˆ ì´ë ‡ê²Œ ì¨ ìˆì—ˆë‹¤.

> **í”„ë¡œí† ì½œ(Protocol)** ì€ **íŠ¹ì • ì—­í• ì„ í•˜ê¸° ìœ„í•œ ë©”ì„œë“œ, í”„ë¡œí„°í”¼, ê¸°íƒ€ ìš”êµ¬ì‚¬í•­ ë“±ì˜ ì²­ì‚¬ì§„** ì„ ì •ì˜í•œë‹¤.
> êµ¬ì¡°ì²´, í´ë˜ìŠ¤, ì—´ê±°í˜•ì€ í”„ë¡œí† ì½œì„ ì±„íƒ(Adopted)í•´ì„œ íŠ¹ì • ê¸°ëŠ¥ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•œ í”„ë¡œí† ì½œì˜ ìš”êµ¬ ì‚¬í•­ì„ ì‹¤ì œë¡œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
> ì–´ë–¤ í”„ë¡œí† ì½œì˜ ìš”êµ¬ì‚¬í•­ì„ ëª¨ë‘ ë”°ë¥´ëŠ” íƒ€ì…ì€ 'í•´ë‹¹ í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•œë‹¤(Conform)'ê³  í‘œí˜„í•œë‹¤.
> íƒ€ì…ì—ì„œ í”„ë¡œí† ì½œì˜ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±ì‹œí‚¤ë ¤ë©´ í”„ë¡œí† ì½œì´ ì œì‹œí•˜ëŠ” ì²­ì‚¬ì§„ì˜ ê¸°ëŠ¥ì„ ëª¨ë‘ êµ¬í˜„í•´ì•¼ í•œë‹¤.
> ì¦‰, **í”„ë¡œí† ì½œì€ ì •ì˜ë¥¼ í•˜ê³  ì œì‹œë¥¼ í•  ë¿ì´ì§€ ìŠ¤ìŠ¤ë¡œ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.**

ê·¸ë ‡ë‹¤ë©´ '**ì™œ ë¹ˆ í”„ë¡œí† ì½œì„ ì •ì˜í–ˆì„ê¹Œ?**' ë¼ëŠ” ì˜ë¬¸ì ì´ ìƒê²¨ ë¹ˆ í”„ë¡œí† ì½œì„ ì •ì˜í•˜ëŠ” ì´ìœ ì— ëŒ€í•´ ì°¾ì•„ë³´ê¸°ë¡œ í–ˆë‹¤.

ë‚´ê°€ ê³µë¶€í•´ ë³¸ ê²°ê³¼ ë¹ˆ í”„ë¡œí† ì½œ(empty protocol)ì„ ì •ì˜í•˜ëŠ” ì´ìœ ëŠ” ë‹¤ìŒê³¼ ê°™ì•˜ë‹¤.

## ë¹ˆ í”„ë¡œí† ì½œ(Empty protocol)ì„ ì •ì˜í•˜ëŠ” ì´ìœ .

ì£¼ë¡œ íƒ€ì…ì˜ ì˜ë¯¸ë‚˜ ìš©ë„ë¥¼ ëª…ì‹œí•˜ê±°ë‚˜ íŠ¹ì •í•œ íƒ€ì… ì œì•½ì„ ì ìš©í•˜ê¸° ìœ„í•¨ì´ë‹¤.

ë¹ˆ í”„ë¡œí† ì½œ(empty protocol)ì€ ë©”ì„œë“œë‚˜ í”„ë¡œí¼í‹°ë¥¼ ì •ì˜í•˜ì§€ ì•Šê³ , ë‹¨ìˆœíˆ íŠ¹ì • íƒ€ì…ì´ íŠ¹ì •í•œ "ë§ˆì»¤"ë‚˜ "íƒœê·¸"ë¥¼ ê°€ì§€ê³  ìˆìŒì„ ë‚˜íƒ€ë‚¸ë‹¤.

ì´ëŸ¬í•œ ì ‘ê·¼ ë°©ì‹ì€ Swiftì˜ íƒ€ì… ì‹œìŠ¤í…œì„ í™œìš©í•˜ì—¬ ì½”ë“œì˜ ì˜ë„ë¥¼ ë” ëª…í™•íˆ í‘œí˜„í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

### ë¹ˆ í”„ë¡œí† ì½œì˜ ì‚¬ìš© ì˜ˆì‹œ.

#### 1. íƒ€ì… ë¶„ë¥˜.

íŠ¹ì •í•œ ëª©ì ì´ë‚˜ ë²”ì£¼ì— ì†í•˜ëŠ” íƒ€ì…ì„ ë¶„ë¥˜í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, **'Serializable'** ì´ë¼ëŠ” ë¹ˆ í”„ë¡œí† ì½œì„ ì •ì˜í•˜ì—¬ ì§ë ¬í™”ê°€ ê°€ëŠ¥í•œ ê°ì²´ë“¤ì„ í‘œì‹œí•  ìˆ˜ ìˆë‹¤.

#### 2. í”„ë¡œí† ì½œ í™•ì¥.

ë¹ˆ í”„ë¡œí† ì½œì„ ì •ì˜í•œ í›„, í”„ë¡œí† ì½œ í™•ì¥ì„ ì‚¬ìš©í•˜ì—¬ ì´ í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•˜ëŠ” ëª¨ë“  íƒ€ì…ì— ëŒ€í•´ ì¶”ê°€ì ì¸ ê¸°ëŠ¥ì´ë‚˜ êµ¬í˜„ì„ ì œê³µí•  ìˆ˜ ìˆë‹¤.
ì´ëŠ” **í”„ë¡œí† ì½œ ì§€í–¥ í”„ë¡œê·¸ë˜ë°**ì˜ ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤.

#### 3. íƒ€ì… ì œì•½ ì¡°ê±´.

ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°ì—ì„œ ë¹ˆ í”„ë¡œí† ì½œì€ íŠ¹ì • íƒ€ì…ì— ëŒ€í•œ ì œì•½ ì¡°ê±´ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.
ì˜ˆë¥¼ ë“¤ì–´, íŠ¹ì • í•¨ìˆ˜ê°€ **'MyProtocol'** ì„ ì¤€ìˆ˜í•˜ëŠ” íƒ€ì…ì—ë§Œ ì‘ë™í•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

#### 4. ì˜ë¯¸ì  í‘œì‹œ.

ì½”ë“œì—ì„œ íŠ¹ì • íƒ€ì…ì´ íŠ¹ë³„í•œ ì˜ë¯¸ë¥¼ ê°€ì§ì„ í‘œì‹œí•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
ì˜ˆë¥¼ë“¤ì–´, **'UserAction'** ì´ë¼ëŠ” ë¹ˆ í”„ë¡œí† ì½œì€ ì‚¬ìš©ìì˜ ì•¡ì…˜ê³¼ ê´€ë ¨ëœ íƒ€ì…ì„ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### 5. ì»´íŒŒì¼ëŸ¬ ì²´í¬ ê°•í™”.

ë¹ˆ í”„ë¡œí† ì½œì„ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • íƒ€ì…ë“¤ì´ íŠ¹ì •í•œ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ê°•ì œí•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ê²€ì¦ë©ë‹ˆë‹¤.

### ì˜ˆì œ ì½”ë“œ.

```swift
protocol Printable { }

extension printable {
    func printDescription() {
        print("I am printable")
    }
}

struct MyData: Printable { }

let data: MyData()
data.printDescription() // ì¶œë ¥: "I am printable"
```

ì´ ì˜ˆì œì—ì„œ, **'Printable'** ì€ ë¹ˆ í”„ë¡œí† ì½œë¡œì„œ, **'printDescription'** í•¨ìˆ˜ë¥¼ í†µí•´ í™•ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.

**'MyData'** êµ¬ì¡°ì²´ëŠ” ì´ í”„ë¡œí† ì½œì„ ì¤€ìˆ˜í•¨ìœ¼ë¡œì¨ í•´ë‹¹ í•¨ìˆ˜ì— ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

### ë¹ˆ í”„ë¡œí† ì½œ ë§ˆë¬´ë¦¬.

ê²°ë¡ ì ìœ¼ë¡œ, ë¹ˆ í”„ë¡œí† ì½œì€ Swiftì˜ ê°•ë ¥í•œ íƒ€ì… ì‹œìŠ¤í…œì„ í™œìš©í•˜ì—¬ í”„ë¡œê·¸ë¨ì˜ ì˜ë„ë¥¼ ëª…í™•í•˜ê²Œ í‘œí˜„í•˜ê³ , ì½”ë“œì˜ ìœ ì—°ì„±ê³¼ ì•ˆì •ì„±ì„ ì¦ê°€ì‹œí‚¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì—¬ê¸°ì—ì„œë„ ë‚´ê°€ ê³µë¶€í•œ ì´ìœ ì™€ ê°™ì€ ì˜ë¯¸ë¡œ ë¹ˆ í”„ë¡œí† ì½œì„ ë§Œë“ ê²ƒì¸ì§€ ê²€ì¦í•  í•„ìš”ê°€ ìˆì—ˆë‹¤.

**ì™œëƒí•˜ë©´ ë‚´ê°€ ê³µë¶€í•œ ê²ƒì´ í‹€ë¦´ ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì´ë‹¤.**

**ê·¸ë˜ì„œ ì´ ë¹ˆ í”„ë¡œí† ì½œì´ ì™œ ì •ì˜ ë˜ì—ˆëŠ”ì§€ ì•Œê¸°ìœ„í•´ ë”°ë¼ê°€ ë³´ì•˜ë‹¤.**

```swift
public struct StructPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    self.x = x
  }

  public var description: String {
    return "â–º\(x)â—€ï¸"
  }
}
```

- line 3 ~ 15

```swift
public struct LargeStructPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let a: Int
  let b: Int
  let c: Int
  let d: Int

  public init(_ a: Int, _ b: Int, _ c: Int, _ d: Int) {
    self.a = a
    self.b = b
    self.c = c
    self.d = d
  }

  public var description: String {
    return "<\(a) \(b) \(c) \(d)>"
  }
}
```

- line 17 ~ 35

```swift
public struct StructVeryPrintable : CustomStringConvertible,
  CustomDebugStringConvertible, ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    self.x = x
  }

  public var description: String {
    return "<description: \(x)>"
  }

  public var debugDescription: String {
    return "<debugDescription: \(x)>"
  }
}
```

- line 49 ~ 65

```swift
public class ClassPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    self.x = x
  }

  public var description: String {
    return "â–º\(x)â—€ï¸"
  }
}
```

- line 92 ~ 104

```swift
public class ClassVeryPrintable : CustomStringConvertible,
  CustomDebugStringConvertible, ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    self.x = x
  }

  public var description: String {
    return "<description: \(x)>"
  }

  public var debugDescription: String {
    return "<debugDescription: \(x)>"
  }
}
```

- line 106 ~ 122

ì´ 5ê°œì˜ ì½”ë“œ ì¡°ê°ì´ ë‚˜ì™”ë‹¤.

ìœ„ì—ì„œ ê³µë¶€í–ˆë“¯ì´ ì´ í”„ë¡œí† ì½œì€

ì£¼ë¡œ íƒ€ì…ì˜ ì˜ë¯¸ë‚˜ ìš©ë„ë¥¼ ëª…ì‹œí•˜ê±°ë‚˜ íŠ¹ì •í•œ íƒ€ì… ì œì•½ì„ ì ìš©í•˜ê¸° ìœ„í•¨ì´ì—ˆë˜ ê²ƒ ê°™ì•˜ë‹¤.

ë„¤ì´ë°ì—ì„œ ì•Œ ìˆ˜ ìˆë‹¤ì‹œí”¼ **'ProtocolUnrelatedToPrinting'** ì€ **print** ì™€ëŠ” ê´€ë ¨ì´ ì—†ëŠ” í”„ë¡œí† ì½œë¡œ ë‚˜ëŠ” í•´ì„í–ˆë‹¤.

ì•„ë§ˆë„ ì´ íŒŒì¼ì€ í…ŒìŠ¤íŠ¸ íŒŒì¼ì´ë‹¤ë³´ë‹ˆ ì € í”„ë¡œí† ì½œì˜ ê¸°ëŠ¥ì€ **print** ì™€ ê´€ë ¨ëœ ê¸°ëŠ¥ì´ ì•„ë‹Œ, ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ê¸°ëŠ¥ì„ ì •ì˜í•˜ëŠ” ê²ƒìœ¼ë¡œ í•´ì„í–ˆë‹¤.

ì¦‰, ì´ í”„ë¡œí† ì½œì´ íŠ¹ì • ë„ë©”ì¸ì´ë‚˜ ê¸°ëŠ¥ì— ì œí•œë˜ì§€ ì•Šê³  ë‹¤ì–‘í•œ ì˜ì—­ì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•¨ì„ ë‚˜íƒ€ë‚´ëŠ” ê²ƒìœ¼ë¡œ í•´ì„í–ˆë‹¤.

ê·¸ ë‹¤ìŒìœ¼ë¡œ ë‚˜ì˜ ëˆˆì„ ë¹¤ì§ì´ê²Œ ë§Œë“  ê²ƒì€ ë°”ë¡œ **"CustomStringConvertible"** ğŸ‘€ í”„ë¡œí† ì½œì´ì˜€ë‹¤.

ìì£¼ ë´¤ë˜ ì¹œêµ¬ì—¬ì„œ ë§¤ìš° ë°˜ê°€ì› ë‹¤.

ê·¸ë˜ì„œ ì´ ì¹œêµ¬ì˜ ì†ì„ ë“¤ì—¬ë‹¤ ë³´ê¸°ë¡œ í–ˆë‹¤.

âœ… 2í¸ì—ì„œ ê³„ì† ë©ë‹ˆë‹¤ !!

---

# print("Hello world!") (1)

The first friend we meet when we start programming is **`print("Hello world!")`**

I became so curious about how this **`print("Hello world!")`** works that I decided to take a look inside.

(You greeted me, but I need to see inside you ğŸ˜†)

<img src = "https://github.com/devKobe24/images/blob/main/%5Bstdlib:test:Print%5D.png?raw=true">

So, I took a look inside **`stdlib/test/Print.swift`**.

Since it's a test file, I thought, 'It must be testing **`Print`**.'

Then, I thought I should look into the libraries imported at the top.

The first place I visited was **`PrintTestTypes`**.

<img src = "https://github.com/devKobe24/images/blob/main/%5Btest:stdlib:inputs:PrintTestTypes.swift%5D.png?raw=true">

I started reading from the very first line.

The first line of code was:

```swift
public protocol ProtocolUnrelatedToPrinting {}
```

Firstly, an empty `public protocol` was created.

The first thought that came to my mind was **'Why?'**

So, I revisited what a **protocol** is by looking through a book.

In [Swift Programming: Swift 5](https://product.kyobobook.co.kr/detail/S000001810190), under the section **'What is a Protocol?'**, it was written:

> A **Protocol** defines the **blueprint of methods, properties, and other requirements for a specific role**.
> Structures, classes, and enumerations can adopt a protocol to implement the requirements of a protocol for specific functionalities.
> A type that satisfies all the requirements of a protocol is said to 'conform to the protocol.'
> To meet the protocol's requirements in a type, all the functionalities presented in the protocol's blueprint must be implemented.
> That is, **a protocol defines and presents, but does not implement functionalities by itself.**

Then, I wondered, **'Why define an empty protocol?'** and decided to research the reasons behind defining an empty protocol (empty protocol).

Based on my research, the reasons for defining an empty protocol (empty protocol) are as follows:

## Reasons for Defining an Empty Protocol (Empty protocol).

Primarily to specify the meaning or purpose of a type or to apply certain type constraints.

An empty protocol (empty protocol) does not define methods or properties but simply indicates that a certain type possesses a specific "marker" or "tag."

This approach helps to express the intent of the code more clearly by utilizing Swift's type system.

### Examples of Using an Empty Protocol.

#### 1. Type Classification.

It can be used to classify types that belong to a specific purpose or category.
For example, a **'Serializable'** empty protocol could be defined to mark objects that are serializable.

#### 2. Protocol Extension.

After defining an empty protocol, protocol extensions can be used to provide additional functionalities or implementations for all types that conform to this protocol.
This is an important part of **protocol-oriented programming.**

#### 3. Type Constraint.

In generic programming, an empty protocol can be used as a constraint for certain types.
For instance, a specific function can be designed to work only with types that conform to **'MyProtocol'.**

#### 4. Semantic Marking.

It can be used when you want to indicate that a specific type has a special meaning in the code.
For example, an empty protocol named **'UserAction'** could signify a type related to user actions.

#### 5. Enhancing Compiler Checks.

An empty protocol can be used to enforce that certain types must meet specific conditions, which are verified at compile time.

### Example Code.

```swift
protocol Printable { }

extension Printable {
    func printDescription() {
        print("I am printable")
    }
}

struct MyData: Printable { }

let data = MyData()
data.printDescription() // Output: "I am printable"
```

In this example, **'Printable'** is an empty protocol that is extended through the **'printDescription'** function.

The **'MyData'** structure can access this function by conforming to this protocol.

### Wrapping up Empty Protocol.

In conclusion, an empty protocol is used in Swift to clearly express the intent of a program and to increase the flexibility and stability of the code.

Then, I needed to verify why this empty protocol was defined here, as it might be for the same reasons I studied.

**Because what I learned could be wrong.**

**So, to find out why this empty protocol was defined, I followed it.**

```swift
public struct StructPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
   

 this.x = x
  }

  public var description: String {
    return "â–º\(x)â—€ï¸"
  }
}
```

- line 3 ~ 15

```swift
public struct LargeStructPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let a: Int
  let b: Int
  let c: Int
  let d: Int

  public init(_ a: Int, _ b: Int, _ c: Int, _ d: Int) {
    this.a = a
    this.b = b
    this.c = c
    this.d = d
  }

  public var description: String {
    return "<\(a) \(b) \(c) \(d)>"
  }
}
```

- line 17 ~ 35

```swift
public struct StructVeryPrintable : CustomStringConvertible,
  CustomDebugStringConvertible, ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    this.x = x
  }

  public var description: String {
    return "<description: \(x)>"
  }

  public var debugDescription: String {
    return "<debugDescription: \(x)>"
  }
}
```

- line 49 ~ 65

```swift
public class ClassPrintable : CustomStringConvertible,
  ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    this.x = x
  }

  public var description: String {
    return "â–º\(x)â—€ï¸"
  }
}
```

- line 92 ~ 104

```swift
public class ClassVeryPrintable : CustomStringConvertible,
  CustomDebugStringConvertible, ProtocolUnrelatedToPrinting {

  let x: Int

  public init(_ x: Int) {
    this.x = x
  }

  public var description: String {
    return "<description: \(x)>"
  }

  public var debugDescription: String {
    return "<debugDescription: \(x)>"
  }
}
```

- line 106 ~ 122

Five code snippets came out.

As I studied, this protocol is mainly for specifying the meaning or purpose of a type or for applying certain type constraints.

As the name suggests, **'ProtocolUnrelatedToPrinting'** is a protocol unrelated to **print**, as I interpreted it.

Perhaps because this file is a test file, the function of this protocol is defined for functionalities other than those related to **print**.

In other words, it signifies that this protocol is not limited to a specific domain or function but can be used in various areas.

Next, what caught my eye was the **"CustomStringConvertible"** ğŸ‘€ protocol.

It was a familiar friend, so I was very pleased to see it.

So, I decided to take a look inside this friend.

âœ… To be continued in part 2 !!
