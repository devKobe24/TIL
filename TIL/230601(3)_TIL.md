# 📖 230601 TIL

---

## 1️⃣ 단방향 리스트로 큐를 구현했을 때의 장점?

단방향 리스트를 사용하여 큐를 구현할 때 다음과 같은 장점이 있습니다.

👉 1. **단순성** : 단방향 리스트는 구조가 간단하여 구현이 상대적으로 쉽습니다. 포인터 또는 참조로 다음 노드로만 관리하면 되므로, 복잡한 연산이나 예외 처리가 필요하지 않습니다.

👉 2. **메모리 효율성** : 큐의 크기가 동적으로 변화할 수 있으므로, 공간 사용이 효율적입니다. 큐에 항목을 추가하거나 제거할 때마다 메모리를 할당하거나 해제할 수 있습니다.

👉 3. **데이터 접근 방식과 일치** : 큐는 FIFO(First In, First Out) 방식으로 동작하는 자료구조입니다. 즉, 가장 먼저 들어온 데이터가 가장 먼저 나가는 구조를 가집니다. 이는 단방향 리스트의 시작(헤드)에서 데이터를 제거하고, 끝(테일)에서 데이터를 추가하는 것과 일치합니다.

> 👉 **단방향 리스트로 큐를 구현시 주의점.**
> 단방향 리스트를 사용하여 큐를 구현할 때, 리스트의 끝에 접근하기 위해 전체 리스트를 순회해야 하는 문제를 피하기 위해 **"테일"** 포인터를 따로 유지해야 한다는 것입니다.
> 이렇게 해야 테일에 새로운 요소를 효율적으로 추가할 수 있습니다.

---

## 2️⃣ Swift에서 큐의 구현이 동적인 이유?

**Swift의 큐 구현이 동적인 이유는 주로 메모리 관리와 데이터 구조의 유연선에 있습니다.**

👉 1. **메모리 관리** : Swift는 ARC(Automatic Reference Counting)를 사용하려 메모리를 관리합니다. 즉, 더 이상 필요하지 않은 객체를 자동으로 메모리에서 해제합니다. 이로 인해 동적으로 요소를 추가하거나 제거할 때 메모리가 필요할 때만 할당하고, 더 이상 필요하지 않을 때 자동으로 해제됩니다. 따라서 메모리 사용이 효율적입니다.

👉 2. **데이터 구조의 유연성** : 큐는 동적 데이터 구조로, 런타임 중에 크기가 변경될 수 있습니다. 즉, 요소를 큐에 추가하면 큐가 자동으로 확장되고, 요소를 큐에서 제거하면 큐가 자동으로 축소됩니다. 이렇게 하면 큐의 크기를 미리 알어내거나 변경할 필요가 없으므로, 구현이 간결해지고 유연성이 향상됩니다.

**따라서, Swift에서의 큐 구현이 동적이라는 것은 메모리 관리와 데이터 구조의 유연성 두 가지 측면에서 장점을 가집니다.**

---

## 3️⃣ 단방향 리스트의 동작 방식?

**단방향 리스트(또는 연결 리스트)는 노드들의 선형 컬랙션입니다.**

각 노드는 두 부분으로 구성됩니다.

하나는 데이터를 포함하고, 다른 하나는 다음 노드에 대한 참조(일반적으로 포인터로 표현)를 포함합니다.

![](https://github.com/devKobe24/images/blob/main/221066355701C41E35.png?raw=true)

다음 노드에 대한 참조는 해당 노드에서 다음 노드로 **"연결"** 을 제공합니다.

이러한 방식으로 노드들이 서로 연결되어 리스트를 형성합니다.

### ✏️ 기본적인 단방향 리스트(연결 리스트)의 동작

👉 1. **삽입** : 새 노드를 리스트의 특정 위치에 삽입할 수 있습니다. 가장 일반적인 삽입 방법은 리스트의 시작(헤드)에 삽입하거나, 리스트의 끝(테일)에 삽입하는 것입니다. 중간 위치에 삽입하는 경우, 삽입할 위치를 찾기 위해 해당 위치까지 리스트를 순회해야 합니다.

👉 2. **삭제** : 특정 노드를 리스트에서 삭제할 수 있습니다. 삭제할 노드의 이전 노드의 **'다음'** 참조를 삭제할 노드의 **'다음'** 노드로 업데이트 해야 합니다. 그런 다음 삭제할 노드는 메모리에서 해제 될 수 있습니다. 만약 삭제할 노드가 리스트의 헤드라면, 헤드 포인터를 삭제할 노드의 **'다음'** 노드로 업데이트해야 합니다.

👉 3. **탐색** : 리스트의 헤드부터 시작하여, **'다음'** 참조를 사용하여 리스트를 순회할 수 있습니다. 이 방식을 사용하면 리스트의 노드를 한 번에 하나씩 방문할 수 있습니다.

> 👉 **단방향 리스트 연산의 단점 및 보완 방법**
> 이러한 연산들은 단방향 리스트가 단방향이므로, 특정 연산들이 비효율적일 수 있음을 의미합니다.
> 예를 들어, 리스트의 끝에서 노드를 삭제하거나 삽입하려면, 해당 위치를 찾기 위해 전체 리스트를 순회해야 합니다.
> 이러한 문제는 추가적인 포인터(예: 테일 포인터)를 유지하거나, 이중 연결 리스트와 같은 다른 자료구조를 사용함으로써 완화될 수 있습니다.

---

## 4️⃣ 테일 포인터란?

**테일 포인터는 연결리스트에서 가장 마지막 노드, 즉 '테일'노드를 가리키는 포인터를 의미합니다.**

**연결 리스트에서는 헤드 포인터(리스트의 첫 번째 노드를 가리키는 포인터)를 유지하는 것이 일반적입니다.**
하지만 경우에 따라 마지막 노드에 빠르게 접근할 필요가 있을 때는 테일 포인터를 유지하는 것이 유용합니다.

예를 들어, 큐를 연결 리스트로 구현할 때, 항상 새로운 요소가 리스트의 끝에 추가됩니다.
테일 포인터가 없다면, 매번 새로운 요소를 추가할 때마다 전체 리스트를 순회해야 하므로 시간 복잡도는 O(n)이 됩니다.

**하지만 테일 포인터를 유지하면, 새로운 요소를 추가하는 데 상수 시간, 즉 O(1)이 걸립니다.**

따라서 테일 포인터는 연산의 효율성을 향상시키는 데 중요한 역할을 합니다.
