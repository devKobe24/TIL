## 🧩 제네릭(Generic), Any 타입이 Equatable을 채택할 수 없는 이유
---

### 😀 제네릭(Generic)이란?</br>

제네릭(Generic)은 Swift와 같은 프로그래밍 언어에서 가용하는 강력한 기능입니다.

유연하고 재사용 가능한 코드를 작성하는 데 도움을 줍니다.

제네릭을 사용하면 여러 타입에 대해 작동하는 함수, 메서드, 클래스, 구조체 및 열거형을 작성할 수 있습니다.

이는 코드 중복을 최소화하고 추상화를 향상시킵니다.

### 😀 제네릭(Generic)의 특징</br>

제네릭(Generic)을 사용하는 코드는 특정 타입을 직접 명시하지 않고, **"플레이스홀더"타입**을 사용합니다.

이 플레이스홀더 타입은 실제 타입을 지정할 때까지 알 수 없습니다.

제네릭을 사용하면 하나의 함수나 클래스를 정의하고, 이를 여러 다른 타입에 대해 사용할 수 있습니다.

### 😀 제네릭(Generic)의 예시</br>

예를 들어 Swift에서 제네릭을 사용하여 모든 타입의 배열에서 특정 항목을 찾는 함수를 작성할 수 있습니다.

```swift!
func findIndex<T: Equatable>(array: [T], valueToFind: T) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

위의 함수는 모든 타입 T에 대해 작동하는데, 이 타입 T는 Equatable 프로토콜을 준수해야 합니다.

> Equatable 프로토콜은 '=='연산자를 사용하여 두 개의 항목이 동일한지 확인할 수 있음을 의미합니다.

따라서 이 함수는 Int, Double, String 등과 같은 다양한 타입의 배열에서 작동합니다.

### 😀 제네릭(Generic)의 장점</br>

제네릭을 이용하면 유연하고 재사용 가능한 코드를 작성할 수 있으며, 앱의 오류 가능성을 줄이고 코드의 가독성을 향상시킬 수 있습니다.

---

### 🐶 Any 타입은 왜 Equatable 프로토콜을 채택할 수 없을까?

먼저 Any 타입에 대해 알아봐야 합니다.

**Swift 언어에서 Any는 모든 타입의 인스턴스를 나타낼 수 있는 특별한 타입입니다.**

이는 구조체, 클래스, 열거형, 함수 타입, 심지어 그 자체로써의 **Any** 타입을 포함한 모든 것을 포함할 수 있습니다.

하지만 **Any** 타입이 **Equatable**을 준수할 수 없는 이유는 **Any**가 알 수 없는 모든 타입의 인스턴스를 나타낼 수 있기 때문입니다.

따라서 **Any** 타입에 대해 '==' 연산자를 적용하는 것은 의미가 없습니다.

**이는 '==' 연산자가 두 개의 값이 동일한지 판단하려면 이 값들이 동일한 타입을 가져야 하기 때문입니다.**

예를 들어, Int와 String은 모두 **'Any'** 타입이 될 수 있지만, 이 두 타입의 값을 서로 비교하는 것은 의미가 없습니다.

이는 '==' 연산자를 사용하여 비교하려는 두 값이 같은 타입이 아니기 때문에 비교 연산이 실패하게 됩니다.

따라서 **Any** 타입이 직접적으로 **Equatable** 프로토콜을 채택하는 것은 불가능합니다.

특정 타입의 값이 **Equatable** 프로토콜을 준수하는지 확인하려면 먼저 이 값을 특정 타입으로 다운캐스팅 한 후에 비교 연산을 수행해야 합니다.
