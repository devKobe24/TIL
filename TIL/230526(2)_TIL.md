# Array(2)
---

### 🙋‍♂️ Topic
- 1️⃣ **Array Literal**
- 2️⃣ **Array Type**
- 3️⃣ **배열 만들기**
- 4️⃣ **요소에 접근하기**

---

✏️ **Array Literal**

✅ 배열은 숫자와 문자열처럼 리터럴이 있습니다.</br>
✅ 아래 문법을 보면 대괄호 안에 요소들을 콤마로 구분해서 나열하고 있습니다.</br>
```swift!
[element, element, ...]
```
✅ 저장 가능한 요소의 수는 문법적으로는 제한이 없습니다.</br>
> 하지만 실제로는 메모리 공간의 제약이 있고 저장된 값의 수를 리턴하는 속성이 Int로 선언되어 있으니 'Int의 Max 값만큼 저장할 수 있다.' 이렇게 생각하면 됩니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.10.09.png?raw=true)

> Int의 Max 값을 확인해 봤습니다. 매우 큰 수가 나옵니다.

✅ 배열의 이름은 복수형태로 만드는게 좋습니다. 또는 Array, List와 같은 접미어를 추가해서 이름만으로 배열인것을 알 수 있게 하는 것이 좋습니다.</br>
```swift!
let nums: [Int] = []
let numArray: [Int] = []
let numList: [Int] = []
```

✅ 아래와 같이 배열에 값을 넣어줄 수 있습니다.</br>
> 대괄호 안에 요소를 넣고 각각의 요소를 컴마로 분리해 줍니다.
```swift!
let nums = [1, 2, 3]
```

🙋‍♂️ 요소의 타입을 알아봅시다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.16.31.png?raw=true)

빨간색 테두리 안에 보면 '[Int]'를 볼 수 있습니다.
이것이 배열의 타입입니다.

**여기서 중요한 것은 대괄호 안에 배열의 타입이 있다는 점 입니다.**

✅ 대괄호 안에 타입이 있다 -> 배열의 타입</br>
✅ 대괄호 안에 요소가 있다 또는 값이 있다 -> 배열 리터럴</br>

🙋‍♂️ **다차원 배열을 만들어봅시다.**

보통은 삼차원 배열까지만 사용하고 사차원 이상은 복잡해서 잘 사용하지 않습니다.

아래의 예시는 이차원 배열입니다.

✅ 아래의 코드와 같이 배열안에 또 다른 배열을 넣으면 됩니다.</br>
```swift!
let multi = [[1,2,3], [4,5,6,]]
```

**여기에서 타입을 확인해봅시다.**
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.23.39.png?raw=true)

위의 그림을 보면 대괄호가 두 번 감싸고 있습니다.
**그래서 대괄호의 갯수를 보고 배열이 몇 차원인지 유추할 수 있습니다.**

✏️ **Array Type**

✅ 배열의 타입을 나타내는 방법은 다음과 같습니다.</br>
```swift!
Array<T>
[T]
```

문자열을 저장하는 문법을 'Array<T>'와 같은 형태의 타입으로 선언하면 다음과 같습니다.
```swift!
let strArray: Array<String>
```
    
이것을 단축 문법으로 선언 해보겠습니다.
```swift!
let strArray: [String]
```
    
✏️ **배열 만들기**

배열을 만들때 가장 쉬운 방법은 배열 리터럴으로 만드는 방법입니다.
```swift!
let nums = [1,2,3]
```

✅ 배열에서는 요소의 타입이 중요합니다.</br>
> 요소의 타입은 초기값으로 추론합니다.
    
만약에 빈 배열을 만들고 싶을 경우, 타입을 명시적으로 선언해주어야 합니다
```swift!
let emptyArray: [Int] = []
let emptyArray2 = Array<Int>()
let emptyArray3 = [Int]()
```

배열을 만들고 초기값을 채우고 싶은 경우에는 아래와 같이 하면 됩니다.
```swift!
let zeroArray = [Int](repeating:0, count: 10)
```

repeating은 채울 값을 의미하고 count는 채울 값의 갯수를 의미합니다.
    
✏️ **Inspecting an Array**

✅ 배열에 저장된 요소의 갯수는 count 속성으로 확인할 수 있습니다.</br>
```swift!
let nums: [Int] = [1,2,3]
nums.count // 3
```
    
✅ 배열이 비어있는지 확인하고 싶을 경우에는 다음과 같은 방법들을 사용할 수 있습니다.</br>
```swift!
nums.count == 0 // false
nums.isEmpty // false
```
단순히 배열이 비어있는지만 확인하고 싶은 경우에는 isEmpty 속성을 사용하는 것이 좋습니다.
    
위의 'nums.count == 0'처럼 비교연산을 할 필요 없이 isEmpty는 바로 Bool 값을 리턴해줍니다.
    
✏️ **Accessing Elements**

✅ 배열에 저장된 요소에 접근할 때는 Subscript 문법을 사용합니다.</br>
> Subscript 문법은 두 가지만 기억하시면 됩니다.
> 1. 대괄호
> 2. 인덱스
    
배열에 저장된 첫 번째 요소에 접근하고 싶을 경우 배열의 이름을 쓰고 대괄호 안에 인덱스를 전달하면 됩니다.
```swift!
let fruits = ["Apple", "Banana", "Melon"]
    
fruits[0] // "Apple"
```

✅ 배열의 인덱스는 항상 0부터 시작합니다.</br>

배열에 저장된 마지막 요소에 접근해봅시다.

✅ 배열의 마지막 요소의 인덱스는 배열의 count에서 1을 뺀 값과 똑같습니다.</br>
> 그 이유는 배열의 인덱스가 0부터 시작하기 때문입니다.
```swift!
fruits[2] // "Melon"
```
    
✅ Subscript 문법에서는 범위도 사용할 수 있습니다.</br>

아래와 같이 범위를 전달하면 그 범위에 맞는 값을 리턴해줍니다.
    
다음의 예시는 0...1이므로 0부터 1번째 까지의 인덱스를 리턴해줍니다.
```swift!
fruits[0...1] // ["Apple","Banana"]
```

배열에서 특정 범위의 요소를 추출하고 싶을때 위와 같이 하면 됩니다.
    
✅ 잘못된 인덱스나 범위를 전달하면 에러가 발생하고 코드 실행이 강제로 종료됩니다.</br>
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.06.22.png?raw=true)
    
그러므로 항상 올바른 인덱스와 범위를 전달하는 것이 중요합니다.
    
✅ 정수 인덱스 대신에 속성으로 제공하는 인덱스를 사용하면 조금 더 안전한 코드를 작성할 수 있습니다.</br>

첫 번째 요소에 접근시 'startIndex' 속성을 사용하면 됩니다.
```swift!
fruits[fruits.startIndex] // "Apple"
```
    
마지막 요소에 접근시 'endIndex' 속성을 사용하면 되지만 그냥 사용해선 안됩니다.
'endIndex'는 마지막 인덱스의 다음 인덱스를 가리킵니다.
그러므로 마지막 요소에 접근하려면 마지막 인덱스의 이전 인덱스로 접근해야 합니다.

✅ 아래와 같이 index(before:) 로 마지막 인덱스를 구해야 합니다.</br>
```swift!
fruits[fruits.index(before: endIndex)] // "Melon"
```

✅ 정수 인덱스 대신에 인덱스 속성을 사용하면 상대적으로는 안전해지지만 여전히 잘못된 인덱스를 전달하면 에러가 발생합니다 따라서 사용에 주의가 필요합니다.</br>

지금처럼 처음이나 마지막 요소에 접근할 수 있는 조금 더 안전한 방법이 있습니다.

✅ 첫 번째 요소는 first 속성으로 접근이 가능합니다.</br>
타입을 보면 옵셔널 타입 입니다.

✅ 마지막 요소는 last 속성으로 접근이 가능합니다.</br>
타입을 보면 옵셔널 타입으로 나타납니다.
    
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.23.12.png?raw=true)

```swift!
fruits.first
fruits.last
```

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.23.03.png?raw=true)
    
✅ 배열이 비여있을 때 숫자를 사용한 인덱스를 사용하여 요소에 접근시 에러가 발생하지만 'first'와 'last' 속성을 이용하면 에러를 발생시키지 않고 'nil'을 return 하고 끝이 납니다. 그래서 조금 더 안전하게 접근이 가능합니다.</br>

특히 마지막 요소에 접근할 때는 요소의 갯수를 확인하고 인덱스에서 1을 빼야하는 번거로운 행위를 해야합니다.

하지만 'last' 속성을 사용할 경우 인덱스를 계산할 필요가 없어 번거로운 행위를 안해도 된다는 장점이 있습니다.

🙋‍♂️ 범위를 지정해서 접근하는 방법을 알아보겠습니다.</br>
    
✅ 주로 원하는 범위를 추출해서 사용하게 됩니다.</br>

먼저 Subscript 문법을 이용해서 범위를 지정해 추출할 수 있습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.27.58.png?raw=true)
    
그 다음은 one sided range도 사용할 수 있습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.29.18.png?raw=true)

✅ one sided range를 for문에서 사용할 때는 무한 루프를 조심해야 합니다.</br>
✅ 배열에서는 범위가 정해져있기 때문에 one sided range를 안전하게 사용이 가능합니다</br>
이렇게 하면 upper bound는 자동으로 배열의 끝이되고 3번째 요소부터 마지막 요소까지 리턴이 됩니다.
반대로 one sided range를 하면 lower bound가 자동으로 0이 됩니다.
그러므로 첫 번째 요소부터 세 번째 요소까지 리턴이 됩니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.53.19.png?raw=true)

✅ prefix와 suffix 메서드 사용도 가능합니다.</br>
아래와 같이 prefix를 호출하고 정수를 전달하면 배열의 시작부분에서 전달한 갯수만큼 새로운 배열을 리턴해줍니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.57.06.png?raw=true)

만약 여기에서 배열에 저장된 갯수보다 더 큰 값을 전달하면 어떻게 될까요?
인덱스라면 문제가 생길 것 입니다.
하지만 전달되는 값이 인덱스가 아니고 최대 갯수이므로 문제 없이 실행됩니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.59.48.png?raw=true)

최대 갯수보다 많을 경우 최대 갯수만큼 잘라서 리턴하는 것 입니다.

아래의 코드에서는 인덱스를 전달하는 것 입니다.
prefix(upto:)는 전달한 인덱스를 포함하지 않습니다.
그러므로 "A", "B", "C" 만 리턴됩니다.

prefix(through:)는 전달한 인덱스까지 포함합니다.
그러므로 "A", "B", "C", "D" 까지 리턴됩니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.04.34.png?raw=true)

✅ 조건을 지정하고 싶은 경우에는 prefix(while:)을 사용합니다.</br>
아래의 조건과 같이 지정할 경우 요소가 C와 같지 않을 때까지 요소를 계속 추출하는 것 입니다.
최종적으로 ["A", "B"]가 리턴됩니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.08.10.png?raw=true)

✅ prefix와 반대로 뒤에서 추출하고 싶을 경우에는 suffix를 사용합니다.</br>
그러면 아래 그림과 같이 뒤에서 부터 3개를 리턴해줍니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.10.25.png?raw=true)

suffix(from:)에서 전달하는 것은 인덱스입니다.
3번 인덱스부터 마지막까지 추출하는 것이니까 ["D", "E"]가 리턴됩니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.13.31.png?raw=true)
