# Swift Standard Libary(1) - Array

**`Swift Standard Libary`** 는 Swift 언어의 핵심 구성 요소를 포함하는 프레임워크입니다.

이 라이브러리에는 Swift 앱을 빌드하는 데 도움이 되는 다양한 도구와 유형이 있습니다.

자신만이 커스텀 데이터 구조 구축을 시작하기 전에 Swift standard libary가 이미 제공하는 기본 데이터 구조를 이해하는 것이 중요합니다.

이 글에서는 표준 라이브러리에서 바로 사용할 수 있는 세 가지 주요 데이터 구조에 중점을두고 설명하겠습니다.

1. 배열(Array).
2. 딕셔너리(Dictionary).
3. 집합(Set).

## Array.

배열은 정렬된 요소 컬렉션을 저장하기 위함 범용 컨테이너로, 모든 종류의 Swift 프로그램에서 일반적으로 사용됩니다.

대괄호로 둘러싸인 쉽표로 구분된 값 목록인 배열 리터럴을 사용하여 배열을 만들 수 있습니다.

예를 들어 다음과 같습니다.

```swift
let people = ["Kobe", "MinSeong", "Jun"]
```

Swift는 프로토콜을 사용하여 배열을 정의합니다.

이러한 각 프로토콜은 배열에 더 많은 기능을 계층화합니다.

예를 들어, `배열`은 `시퀀스`이므로 적어도 한 번은 반복할 수 있습니다.

또한 `컬렉션`이므로 비파괴적으로 여러 번 순회할 수 있고 subscript operator(아래첨자 연산자)를 사용하여 액세스할 수 있습니다.

> **`Protocol(프로토콜)`**
> 
> 특정 작업이나 기능을 수행하기 위해 필요한 메서드나 프로퍼티 또는 기타 요구사항들의 청사진을 정의합니다.
> 
> 클래스, 구조체, 열거형은 이 프로토콜을 채택(Adopt)하여 이러한 요구사항들을 실제 구현(Implement)할 수 있습니다.
> 
> 이는 일종의 계약과 같아서, 특정 프로토콜을 채택한 타입은 프로토콜이 요구하는 기능을 반드시 구현해야 합니다.
> 
> 프로토콜의 주요 장점은 다음과 같습니다.
> > 1. **재사용성 :** 공통의 프로토콜을 채택함으로써, 다양한 타입들이 동일한 기능을 재사용할 수 있습니다.
> > 
> > 2. **유연성과 확장성 :** 새로운 기능을 기존 코드에 쉽게 추가할 수 있습니다. 프로토콜을 확장(Extension)하여 기분 구현을 제공함으로써, 모든 채택 타입에 대해 이 기능을 사용할 수 있게 합니다.
> > 
> > 3. **Decoupling :** 타입이 특정 프로토콜만을 알면 되므로, 구현에 대한 자세한 내용을 몰라도 타입을 사용 할 수 있습니다. 이는 타입 간의 종속성을 줄이고, 유닛 테스트의 용이성을 높입니다.

배열은 효율성을 보장하는 `RandomAccessCollection`이기도 합니다.

Swift `배열`은 모든 유형에서 작동할 수 있기 때문에 일반 컬렉션으로 알려져 있습니다.

실제로 대부분의 Swift 표준 라이브러리는 제네릭 코드로 구축되어 있습니다.

> **`Generic(제네릭)`**
> 
> Swift에서 제네릭(Generic)은 타입에 유연하고 재사용 가능한 코드를 작성할 수 있게 하는 강력한 기능입니다.
> 
> 제네릭을 사용하면 타입 매개변수를 이용하여 타입에 독립적인 방식으로 함수, 구조체, 클래스, 열거형 등을 정의할 수 있습니다.
> 
> 제네릭의 주요 장점은 다음과 같습니다.
> 
> > 1. **타입 안전성(Type Safety) :** 제네릭을 사용하면 컴파일 타임에 타입을 결정하므로, 런타임 오류를 줄일 수 있습니다. 타입이 명확하기 때문에, 잘못된 타입 사용을 방지할 수 있습니다.
> > 
> > 2. **재사용성(Reusability) :** 한 번의 구현으로 다양한 타입에 대응할 수 있으므로, 코드의 재사용성이 높아집니다.
> > 
> > 3. **유연성(Flexibility) :** 제네릭은 다양한 타입에 유연하게 적용될 수 있어, 타입에 구애받지 않는 범용적인 코드를 작성할 수 있습니다.

모든 데이터 구조와 마찬가지로 알아야 할 몇가지 주목할 만한 특성이 있습니다.

첫 번째는 **순서**의 개념입니다.

## 순서

배열의 요소는 명시적으로 순서가 지정됩니다.

위의 `people` 배열을 예로 들면 `"Kobe"`가 `"MinSeong"` 앞에 옵니다.

배열의 모든 요소에는 해당 zero-based 정수 인덱스가 있습니다.

예를 들어 `people` 배열에는 각 요소에 해당하는 인덱스가 3개가 있습니다.

다음과 같이 작성하면 배열의 요소 값을 검색할 수 있습니다.

```swift
people[0] // "Kobe"
people[1] // "MinSeong"
people[2] // "Jun"
```

순서는 배열 데이터 구조에 의해 정의되며 당연한 것으로 간주해서는 안 됩니다.

`Dictionary` 같은 일부 데이터 구조는 순서에 대한 개념이 약합니다.

### Random-access(무작위 접근)

무작위 접근은 데이터 구조가 일정한 시간 내에 요소 검색을 처리할 수 있는 경우 주장할 수 있는 특성입니다.

예를 들어, `people` 배열에서 `"Jun"`를 가져오는 데 일정한 시간이 걸립니다.

다시 말하자면, 이러한 성능을 당연시해서는 안 됩니다.

linked list나 trees와 같은 다른 데이터 구조는 일정한 시간에 접근(access)할 수 없습니다.

## Array performance(배열 성능)

무작위 접근(Random-access) 컬렉션 외에도 개발자로서 관심을 가질 만한 다른 성능 영역, 특히 데이터 구조에 포함된 데이터의 양이 증가해야 할 때 데이터 구조가 얼마나 잘 또는 제대로 작동할까요?

배열의 경우 이는 두 가지 요소에 따라 달라집니다.

### Insertion location(삽입 위치)

첫 번째 요소는 배열 내부에 새 요소를 삽입하도록 선택하는 요소입니다.

배열에 요소를 추가하는 가장 효율적인 시나리오는 배열 끝에 요소를 추가하는 것입니다.

```swift
people.append("Mary")
print(people) // prints ["Kobe", "MinSeong", "Jun", "Mary"]
```

추가 메서드를 사용하여 "Mary"를 삽입하면 문자열이 배열의 끝에 배치됩니다.

이는 상수 시간 연산이므로 배열이 아무리 커져도 이 연산을 수행하는 데 걸리는 시간은 동일하게 유지됩니다.

그러나 배열의 맨 가운데와 같이 특정 위치에 요소를 삽입해야 할 때가 있을 수 있습니다.

> **상수 시간(Constant Time)**
> 
> 연산이나 함수의 실행 시간이 입력 크기에 상관없이 일정하다는 것을 의미합니다.
> 
> 이를 빅 오 표기법으로 표현하면 `O(1)`으로 나타냅니다.
> 
> 상수 시간 연산의 예로는 배열에서 인덱스를 사용한 요소 접근이 있습니다.
> 
> 상수 시간 특성을 가진 연산의 특징은 다음과 같습니다.
> 
>> 1. **입력 크기와 무관 :** 연산을 수행하는 데 걸리는 시간이 입력 데이터의 크기나 요소의 개수와 관계가 없습니다. 즉, 10개의 요소를 가진 배열에 접근하는 데 걸리는 시간이 10,000개 요소를 가진 배열을 접근하는 시간과 같습니다.
>> 
>> 2. **예측 가능성 :** 시간 복잡도가 `O(1)`인 연산은 예측이 가능합니다. 이는 시스템의 성능을 예측하고 보장하는 데 유용합니다.
>> 
>> 3. **효율성 :** 상수 시간 연산은 일반적으로 매우 빠르며, 알고리즘의 전체 효율성을 높이는 데 기여합니다.
>
> 그러나 상수 시간이라고 해서 항상 연산이 **"빠르다"** 는 것을 의미하지는 않습니다.
> 
> 상수 시간은 단지 연산 시간이 고정되어 있고 입력 크기에 의존하지 않는다는 것을 의미할 뿐, 실제로 걸리는 시간은 다를 수 있습니다.
> 
> 예를 들어, 어떤 상수 시간 연산은 1초가 걸릴 수도 있고, 다른 상수 시간 연산은 0.001초가 걸릴 수도 있습니다.
> 
> 중요한 것은 입력 크기가 커져도 이 시간이 변하지 않는다는 점입니다.
> 
> 상수 시간은 보통 간단한 연산에 적용되며, 복잡한 로직이나 루프, 재귀 호출이 없을 때 사용됩니다.
> 
> 예를 들어, 해시 테이블에서 키를 사용한 데이터 접근이나, 큐와 스택에서의 push와 pop 연산 등이 일반적으로 상수 시간에 수행 될 수 있습니다.
> 
> 그러나 해시 테이블의 경우, 최악의 시나리오에서는 해시 충돌로 인해 상수 시간을 보장하지 못할 수도 있습니다.

그 이유를 설명하기 위해 다음과 같은 비유를 생각해볼 수 있습니다.

영화관에서 팝콘을 사기 위해 줄을 서고 있습니다.

새로운 사람이 줄에 합류합니다.

그 사람을 줄에 추가하기 가장 쉬운 곳은 어디일까요?

당연히 맨 끝입니다!!

새로 들어온 사람이 줄 중간에 끼어들려고 하면 줄의 절반을 설득해 자리를 만들거나 사람들이 불만을 가질 수 있을겁니다.

그리고 무례한 사람이라면 줄 맨 앞에 자신을 끼워 넣으려고 할 것입니다.

이 경우 줄에 있던 모든 사람이 앞사람을 위한 공간을 확보하기 위해 뒤로 물러나야 하므로 정말 최악의 시나리오입니다!!

이것이 바로 배열이 작동하는 방식입니다.

배열이 끝을 제외한 다른 곳에서 새 요소를 삽입하면 요소를 위한 공간을 확보하기 위해 요소가 강제로 밀려나게 됩니다.

```swift
people.insert("Ruby", at: 0)
// ["Ruby", "Kobe", "MinSeong", "Jun", "Mary"]
```

정확히 말하면, 모든 요소는 인덱스 하나씩 뒤로 이동해야 하며, 이 작업에는 n단계가 소요됩니다.

배열의 요소(element) 수가 두 배가 되면 이 `삽입(insert)` 작업에 필요한 시간도 두 배가 됩니다.

컬렉션 앞에 요소를 삽입하는 것이 프로그램의 일반적인 작업인 경우 데이터를 저장할 다른 데이터 구조를 고려할 수 있습니다.

삽입 속도를 결정하는 두 번째 요소는 Array의 용량입니다.

내부적으로 Swift의 배열은 요소에 대해 미리 정해진 양의 공간이 할당되어 있습니다.

이미 최대 용량에 도달한 배열에 새 element를 추가하려고 하면, 배열은 더 많은 element를 위한 공간을 확보하기 위해 자체적으로 재구성해야 합니다.

이 작업은 배열의 모든 현재 요소를 메모리의 새롭고 더 큰 컨테이너에 복사하는 방식으로 수행됩니다.

그러나 배열의 각 element를 방문하여 복사해야하므로 비용이 발생합니다.

즉, 마지막에 삽입하더라도 복사가 이루어지면 완료하는 데 n단계가 걸릴 수 있습니다.

하지만 표준 라이브러리는 이러한 복사 시간을 최소화하는 전략을 사용합니다.

스토리지가 부족하여 복사해야 할 때마다 용량을 두 배로 늘립니다.
