# Array(4)
---

### 🙋‍♂️ Topic
- 1️⃣ **배열 비교**
- 2️⃣ **요소 검색**
- 3️⃣ **정렬**
---

✏️ **배열 비교**
```swift!
let a = ["A", "B", "C"]
let b = ["a", "b", "c"]
```

위 코드를 보면 a에는 대문자, b에는 소문자가 저장되어 있습니다.

비교할 때는 '비교 연산자'를 사용합니다.
```swift!
a == b // false 
a != b // true
```

배열을 위와 같이 비교할 수 있습니다.
결과를 보면 두 개가 다른 배열임을 알 수 있습니다.

**배열에 포함되어 있는 값이 똑같고 똑같은 순서로 저장되어 있어야지만 같은 배열입니다.**

위 코드는 대소문자가 다르므로 다른 배열로 판단하는 것 입니다.

**메소드로 비교도 가능합니다.**
```swift!
a.elementsEqual(b) // false 
```

'elementsEqual(_ other:by:)' 메서드는 비교 방식을 직접 구현할 수 있습니다.
```swift!
a.elementsEqual(b, by: { (lhs, rhs) -> Bool in 
    return lhs.caseInsensitiveCompare(rhs) == .orderedSame
}) // true

a.elementsEqual(b) { $0.caseInsensitiveCompare($1) == .orderedSame } // true
```
위 코드는 대소문자를 무시하고 비교하는 비교 방식을 직접 구현한 것 입니다.

**이렇게 배열의 동일성을 비교가 가능하나 크기나 순서는 비교할 수 없습니다.**
```swift!
a < b // error!!
```
연산자 메서드를 공부하고 나면 이렇게 연산자를 이용해 구현은 가능합니다.
나중에 연산자 메서드를 공부한 후에 다시 알아보겠습니다.

---

✏️ **요소 검색**

이번에는 검색을 해보겠습니다.

아래 코드에는 순서가 없는 숫자 배열이 있습니다.

배열에서 가장 작은 값을 가져오고 싶다면 'min()' 메서드를 사용합니다.
```swift!
let randomNumbers = [1,2,3,1,4,5,2,6,7,5,0]
randomNumbers.min() // 0
```
그러면 0이 리턴됩니다.

**문자열도 아스키 코드를 비교할 수 있습니다.**

```swift!
let a = ["A", "B", "C"]
a.min() // "A"
```

a 배열에서 아스키 코드가 가장 작은 "A"가 리턴 됩니다.

숫자나 문자열은 순서를 비교할 수 있습니다.
따라서 min() 과 같이 바로 가져올 수 있습니다.

하지만 우리가 직접 타입을 만들면 컴파일러가 어떤게 크고 어떤게 작은지 이런것을 알 수 없습니다.
만약에 이런 경우라면 'min(by:)' 메서드를 사용해서 크기를 어떻게 판단할지 직접 구현할 수 있습니다.

```swift!
randomNumbers.min(by: ...)
```

반대로 가장 큰 값을 가져오고 싶다면 'max()'를 사용하면 됩니다.
```swift!
randomNumbers.max() // 7
```

또한 'max(by:)'를 통해서 크기를 비교하는 코드를 직접 구현할 수 있습니다.
```swift!
randomNumbers.max(by: ...)
```

배열에 값이 포함되어 있는지 확인하고 싶을 경우에는 'contains()' 메서드를 사용합니다.
```swift!
randomNumbers.contains(1) // true
```

위와 같이 값을 전달하면 해당 값이 포함되어 있는지 확인할 수 있습니다.

그리고 'contains(where:)'의 경우에는 where로 값을 확인하는 코드를 직접 구현할 수 있습니다.

아래 예시에서는 짝수가 포함되어 있는지 확인해보겠습니다.
```swift!
let result = randomNumbers.contains { $0.isMultiple(of:2) }
result // true
```

'containts' 메서드는 단순히 존재 여부만 확인하는 메서드입니다.

index를 검색하거나 요소를 검색할 수 있는 메서드도 있습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.08.02.png?raw=true)

위 그림과 같이 'first'라고 검색해보면 여러가지 메서드들이 자동으로 나오게 됩니다.
- firstIndex(of:)의 경우 요소를 검색한 후 검색한 첫 번째 요소의 인덱스를 리턴합니다.
- firstRange(of:)의 경우 첫 번째로 검색된 범위를 리턴합니다.
- 나머지는 가장 먼저 검색된 요소를 리턴합니다.
- 값을 전달하는 메서드도 있고 클로저를 전달하는 메서드도 있습니다.

first(where:)를 사용해서 검색 조건을 전달해보겠습니다.

클로저에서 가장 먼저 true를 리턴하는 요소를 최종 결과로 return하는것 입니다.
true를 return하는 요소가 없다면 검색에 실패한 것 입니다.
이때는 nil을 리턴합니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.20.43.png?raw=true)

위 그림에서 보다시피 가장 먼저 검색된 짝수 2가 return되고 있습니다.

이번에는 'firstIndex(of:)'를 사용해보겠습니다.
of 에 클로저를 전달해보겠습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.24.11.png?raw=true)
이번에는 1이 return 됩니다.
이것은 배열에 저장된 값이 아닙니다.
인덱스 입니다.
2의 인덱스가 리턴되는 것 이니까 1이 리턴되는 것 입니다.

이번에는 'firstIndex(of:)'의 of에 값을 전달해보겠습니다.

그러면 해당 값을 검색하는 기능이 됩니다.

첫 번째로 검색된 값의 인덱스를 리턴해줍니다.

값이 없다면 nil을 리턴합니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.27.22.png?raw=true)

'last'의 경우 시작 위치만 빼고 'first'와 같은 기능을합니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.29.04.png?raw=true)

'lastIndex(of:)'를 사용해보겠습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.33.27.png?raw=true)
배열을 보면 5라는 숫자가 2개가 저장되어 있습니다.

firstIndex(of:)는 시작위치에서 검색을 하니 첫 번째 5의 인덱스인 5가 리턴되고, 반대로 lastIndex(of:)는 뒤에서 검색을 하니 두 번째 인덱스가 리턴됩니다 그래서 인덱스 9가 리턴되는 것 입니다.

---

✏️ **정렬**

정렬에는 크게 2가지 방법이 있습니다.

1. 복사본 배열을 정렬하여 리턴
2. 원본 배열을 직접 정렬

✅ **복사본을 정렬해서 리턴하는 방법**</br>
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.36.09.png?raw=true)

위 그림을 보면 숫자들이 작은 것부터 큰 것 순서로 오름차순으로 정렬된 것을 확인할 수 있습니다.

원본 배열을 확인해보겠습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.37.59.png?raw=true)

원본 배열은 그대로 있는 것을 확인할 수 있습니다.

'sorted()'는 새로운 복사본을 만들어서 오름차순으로 정렬 후 리턴하는 것 입니다.

항상 오름차순으로 정렬하니 내림차순으로 정렬할 수 없습니다.

요소의 크기를 비교할 수 없을 때에도 사용할 수 없습니다.

이때는 클로저로 직접 크기를 비교해야 합니다.

이번에는 'sorted(by:)'를 사용하여 내림차순으로 정렬해보겠습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.43.13.png?raw=true)

위 그림에서 보시다시피 큰 숫자부터 작은 숫자로 내림차순으로 정렬됩니다.

'sorted()'와 'reversed()'를 같이 활용해서 내림차순으로 정렬하는 방법도 있습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.54.01.png?raw=true)
그러나 이렇게하면 타입이 달라집니다.

타입이 'ReversedCollection' 이렇게 나와있습니다.

이것은 새로운 배열을 만들지 않고 원본과 메모리를 공유하면서 역순으로 접근을 할 수 있게 해주는 것 입니다.

값을 읽기만 한다면 이대로 사용해도 됩니다.

하지만 새로운 배열을 만들고 싶다면 아래 그림과 같이 생성자로 전달해서 만들 수 있습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.56.15.png?raw=true)

✅ **원본을 정렬해서 리턴하는 방법**</br>

'sort()'메서드를 이용합니다. 이 메소드는 'ed'가 빠진것을 볼 수 있습니다.

원본을 정렬 후 배열을 리턴하지 않는다는 차이점이 있습니다.

구현 패턴은 똑같습니다.

원본을 바꾸는 배열은 'let'으로 선언한 '불변 배열'에서는 사용할 수 없습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.01.17.png?raw=true)

위 그림에서 볼 수 있다시피 원본이 오름차순으로 정렬됩니다.

'reverse()' 메서드를 사용해서 원본을 뒤집을 수도 있습니다.
![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.03.30.png?raw=true)

전체를 정렬하는 것이 아니고 특정 요소의 순서만 'swap()'을 활용하여 바꿀 수 있습니다.

이번에 0번 인덱스와 1번 인덱스를 바꿔보겠습니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.05.59.png?raw=true)

위와 같이 전달한 인덱스의 요소들의 자리를 바꿔줍니다.

'shuffle()' 메서드는 순서를 무작위로 섞어줍니다.

이 메서드는 ed가 포함되어 있는 것이 있고 없는 것이 있습니다.
(ed가 붙고 안붙고의 차이는 ed가 붙으면 복사본을 바꾸는 것이고 아니면 원본을 바꾸는 것 입니다.)

다음 그림과 같이 'shuffle()' 또는 'shuffled()'를 실행하면 매번 무작위로 바뀝니다.

![](https://github.com/devKobe24/images/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-05-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.10.42.png?raw=true)
