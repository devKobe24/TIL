# main.async 👀</br>
```swift!
import Foundation

DispatchQueue.main.async {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

DispatchQueue.main.async {
	for _ in 1...5 {
		print("🥶🥶🥶🥶🥶")
		sleep(2)
	}
}

/* 출력 결과
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
*/
```

main 스레드에 비동기(async)로 일을 처리하는 코드입니다.
다른 스레드를 새로 만들지 않고 main 스레드에서만 일을 처리하고 있습니다.
비동기(async)로 작업을 처리했기에 '작업을 기다리지 않고 다음 작업이 실행되야하지 않나?'라고 생각할 수도 있을 것 같습니다.
작업이 끝나기를 기다리지는 않고 있지만 main 스레드라는, 
단일 스레드에서만 작업이 이루어지고 있기 때문에 동시에 작업이 처리되지는 못하는 것입니다.
따라서 쌓인 순서대로 작업이 처리되는 것입니다.

<img src = "https://github.com/devKobe24/images/blob/main/syncAndAsync2.gif?raw=true"></br>

async가 작업을 기다리지 않고 다음 작업을 실행시키고 있음은 아래의 코드를 통해서 확인할 수 있습니다.

```swift!
DispatchQueue.main.async {
	for _ in 1...5 {
		print("😀😀😀😀😀")
		sleep(1)
	}
}

for _ in 1...5 {
	print("🥶🥶🥶🥶🥶")
	sleep(2)
}

/* 출력 결과
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
🥶🥶🥶🥶🥶
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
😀😀😀😀😀
*/
```

위 코드를 실행 시키면 어떻게 될까요?
스레드가 1개이니, 먼저 호출된 😀😀😀😀😀가 먼저 출력되어야 할 것 같지만,
대게 🥶🥶🥶🥶🥶가 먼저 출력되곤 합니다.(정확히는 어떤 것이 먼저 출력될지 모릅니다.)
**그 이유는 단일 스레드 환경이지만 비동기(async)로 코드 블록을 호출했기 때문에 작업이 끝나기를 기다리지 않고 다음 코드로 넘어가버린 것입니다.**

이때 다음 코드가 먼저 실행이 된다면 😀😀😀😀😀의 출력은 그 다음으로 미루어질 것 입니다.
단일 스레드에서 처리되는 것이기 때문입니다.
이러한 async의 특성은 global 스레드 환경에서도 그대로 나타납니다.
