# TDD(Test-Driven Development)에서 Mock 객체에 Protocol을 만드는 이유? 👀</br>

**✅ Test-Driven Development(TDD)에서 Mock 객체를 사용하는 목적은 실제 객체를 테스트하면서 의존성을 갖는 다른 부분들로 인한 문제를 분리하고, 테스트하려는 로직에 집중하기 위함입니다.**

Protocol을 사용하여 Mock 객체를 만드는 이유는 몇 가지 있습니다.

1. 의존성 역전: 실제 클래스나 구조체보다는 Protocol에 의존하도록 코드를 작성하면, 해당 클래스나 구조체가 변경되어도 의존성이 느슨하게 연결되어 있어 변경에 대한 영향을 최소화할 수 있습니다.
2. 확장성: Protocol을 사용하면 코드를 좀 더 유연하게 만들 수 있습니다. 새로운 기능을 추가하거나 기존 기능을 변경해야 할 때, Protocol을 따르는 다른 타입을 만들어 쉽게 교체할 수 있습니다.
3. 테스트 용이성: Mock 객체에서 Protocol을 사용하면, 테스트 케이스에서 필요한 메서드만을 정의하여 사용할 수 있으며, 이는 테스트의 복잡성을 줄여줍니다.

**🙌 따라서, Protocol을 사용하여 Mock 객체를 만드는 것은 TDD에서 매우 중요한 개념이며, 코드의 유지 보수성과 확장성을 향상시키는데 도움을 줍니다.**

# TDD(Test-Driven Development)에서 Stub 객체에 Protocol을 만드는 이유? 👀</br>

**✅ Stub 객체는 테스트 과정에서 실제 객체를 대체하는 역할을 합니다</br>Stub 객체는 실제 객체와 동일한 인터페이스(프로토콜)를 가집니다.</br>이는 실제 객체의 동작을 모방하면서도 원하는 결과를 반환하도록 설정할 수 있게 합니다.**

Stub 객체에 프로토콜을 사용하는 이유는 주로 다음과 같습니다.

1. 행동 확인: Stub 객체는 실제 객체와 동일한 프로토콜을 구현하므로, 테스트하는 코드는 실제 객체인지 Stub 객체인지 알 수 없습니다.</br>이를 통해 실제 객체의 기대되는 행동을 Stub 객체를 통해 검증할 수 있습니다.
2. 결과 제어: Stub 객체를 사용하면 특정 메소드가 호출될 때 원하는 값을 반환하도록 설정할 수 있습니다.</br>이는 예를 들어, 네트워크 요청이나 데이터베이스 접근과 같이 외부 시스템에 의존하는 동작을 테스트할 때 유용합니다.</br>이러한 경우 실제 외부 시스템을 사용하면 테스트가 느려지거나, 일관된 결과를 얻기 어려울 수 있습니다.
3. 의존성 분리: Stub 객체와 프로토콜을 사용하면 테스트하려는 코드와 그 외의 코드를 분리할 수 있습니다.</br>이는 코드의 결합도를 낮추고, 코드의 유지 보수성과 가독성을 높입니다.

**🙌 따라서, Stub 객체에 프로토콜을 사용하는 것은 TDD 방식으로 소프트웨어를 개발할 때 흔히 사용되는 방법입니다.**

## "Mock 객체"와 "Stub 객체"의 차이점 📚</br>

**✅ "Mock 객체"와 "Stub 객체"는 모두 테스트에서 사용되는 용어로, 둘 다 테스트를 도와주는 가짜 객체(fake object)입니다. 하지만 그 사용 목적과 기능에는 몇 가지 차이점이 있습니다.**

1. Mock 객체: Mock 객체는 테스트 대상이 정확한 동작을 수행했는지 검증하기 위해 사용됩니다.</br>즉, 테스트 대상이 Mock 객체와 상호작용하는 방식을 테스트하는 것이 주 목적입니다.</br>Mock 객체는 특정 메서드가 호출되었는지, 어떤 인자와 함께 호출되었는지, 몇 번 호출되었는지 등을 확인하는데 사용될 수 있습니다.</br>이러한 검증이 가능하기 때문에 Mock 객체는 테스트에서 예상된 동작을 스펙화(spcecify)하는 데 중요한 역할을 합니다.
2. Stub 객체: Stub 객체는 테스트 대상 코드가 실행되는 동안 필요한 입력 값을 제공하기 위해 사용됩니다.</br>즉, 테스트 대상이 Stub 객체로부터 예상하는 값을 얻을 수 있게 해주는 것이 주 목적입니다.</br>Stub 객체는 테스트가 실행되는 동안 일관된 동작을 보장하며, 실제 객체를 사용하는 것보다 테스트를 더 간단하고 예측 가능하게 만듭니다.

**✏️ 즉, Mock 객체는 테스트 개상의 동작을 검증하는데 초점을 맞추며, Stub 객체는 테스트 대상에게 필요한 입력을 제공하는데 중점을 둡니다.**</br>

둘 다 테스트를 위한 도구지만 사용 목적과 역할에 따라 적절하게 사용되어야 합니다.

## 용어 사전 📓</br>
1️⃣ **스펙화(Specify)**</br>

**"스펙화(Specify)"는 여기서 시스템이 어떻게 동작해야 하는지 명세하는 것을 의미합니다.</br>즉, 시스템의 기능, 동작, 제약 조건 등을 명확하게 정의하고 설명하는 과정을 말합니다.**</br>

테스트 주도 개발(TDD)과 같은 방법론에서는 이러한 스펙화 과정이 중요합니다.
그 이유는 개발자는 테스트 케이스를 작성함으로써 소프트웨어가 수행해야 할 특정 기능을 미리 명세(specify)하게 됩니다.
그 후에 이 테스트 케이스가 통과할 수 있도록 코드를 작성하게 됩니다.

위에서 언금한 Mock 객체에서의 "스펙화"는 이와 비슷한 맥락입니다.
Mock 객체를 사용하면 시스템의 특정 부분이 어떻게 동작해야 하는지를 미리 명세하고, 
그에 따라 시스템이 정확하게 동작하는지를 테스트하게 됩니다.
이를 통해 시스템의 특정 통작을 예측 가능하게 만들고, 이해하기 쉬운 코드를 작성할 수 있습니다.

2️⃣ **시스템(System)**</br>

**"시스템(System)"이라는 단어는 다양한 문맥에서 여러 가지 의미를 가질 수 있습니다.</br>그러나 컴퓨터 과학과 소프트웨어 엔지니어링 분야에서 "시스템"은 일반적으로 연관된 컴포넌트들의 집합으로, 주어진 목적을 달성하기 위해 함께 작동하는 것을 지칭합니다.**

이 컴포넌트들은 하드웨어, 소프트웨어, 데이터베이스, 네트워크 장비 등 다양한 것들이 될 수 있으며,
이들은 특정 정보를 처리하거나, 사용자의 요청에 응답하거나, 원하는 결과를 생성하기 위해 상호작용합니다.

소프트웨어 엔지니어링에서 "시스템"은 더 구체적으로 특정 소프트웨어 어플리케이션, 웹사이트, 네트워크 인프라 등을 가리키는 경우가 많습니다.
예를 들어, 특정 웹 애플리케이션을 "시스템"이라고 부를 수 있습니다.
이런 경우, 이 시스템은 서버, 데이터베이스, 클라이언트 사이드 코드 등 여러 컴포넌트로 구성됩니다.
이 컴포넌트들이 서로 상호작용하여 웹 애플리케이션의 전체 기능을 제공합니다.

3️⃣ **컴포넌트(Component)**</br>

**컴퓨터 과학과 소프트웨어 엔지니어링에서 "컴포넌트(Component)"는 시스템의 일부분이며, 주어진 기능을 수행하도록 설계된 독립적인 모듈을 의미합니다.</br>각 컴포넌트는 자체 기능을 가지며, 다른 컴포넌트와 인터페이스를 통해 통신하고 상호 작용합니다.**

컴포넌트는 다음과 같은 특성을 가지고 있습니다

1. 독립성 : 컴포넌트는 독립적으로 운영될 수 있어야 하며, 다른 컴포넌트와 최소한의 의존성을 가져야 합니다.
2. 재사용성 : 컴포넌트는 여러 시스템에서 사용될 수 있어야 하며, 이를 통해 코드의 재사용성을 높이고 유지 관리를 효과적으로 수행할 수 있습니다.
3. 대체 가능성: 필요에 따라 같은 인터페이스를 가진 다른 컴포넌트로 쉽게 대체될 수 있어야 합니다.

예를 들어, 웹 애플리케이션에서 데이터베이스 접근을 처리하는 모듈, 사용자 인터페이스를 담당하는 모듈,
서버와의 통신을 담당하는 모듈 등이 각각 독립적인 컴포넌트로 볼 수 있습니다.
이러한 컴포넌트들은 각자의 역할을 수행하면서 전체 시스템의 기능을 이루어냅니다.

4️⃣ **모듈(Module)**</br>

**"모듈(Module)"이란 소프트웨어 설계에서 독립적인 역할을 수행하는 코드의 단위를 말합니다.</br>각 모듈은 특정 기능을 수행하기 위한 코드로 구성되어 있으며, 다른 모듈과는 분리되어 있습니다.</br>이렇게 분리되어 있는 구조 덕분에 개발자들은 복잡한 프로그램도 여러 개의 작은 모듈로 나눠서 관리하고 개발할 수 있습니다.**

모듈은 다음과 같은 특성을 가집니다.

1. 독립성 : 모듈은 다른 모듈로부터 독립적으로 실행될 수 있어야 하며, 모듈 간 상호작용은 잘 정의된 인터페이스를 통해 이루어져야 합니다.
2. 재사용성 : 잘 설계된 모듈은 필요에 따라 다른 프로그램에서도 재사용될 수 있습니다.
3. 단일 책임 원칙 : 각 모듈은 한 가지 기능에만 집중해야 합니다. 이를 통해 코드의 가독성과 유지 보수성을 향상 시킬 수 있습니다.
4. 은닉화 : 모듈은 자신이 담당하는 기능과 데이터를 외부로부터 숨기는 역할을 합니다. 이를 통해 다른 모듈이 내부 구현에 의존하지 않게 하고, 모듈 내부의 변경이 다른 모듈에 영향을 주지 않도록 합니다.

이런 방식으로 모듈을 사용하면, 전체 시스템의 복잡성을 관리하고, 코드의 가독성을 높이며, 재사용성을 증가시키고, 유지 보수를 용이하게 할 수 있습니다.
