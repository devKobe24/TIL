# 🧩 Queue, List 그리고 Linked List

## 🧩 Queue
🤔 **큐(Queue)?**</br>
**큐(Queue)는 컴퓨터 과학의 기본적인 자료구조 중 하나입니다.**

🤔 **큐의 구조**</br>
**큐(Queue)는 항목들이 들어오는 순서대로 나가는 구조를 가집니다.**
이러한 특성 때문에 큐는 **FIFO(First-In,First-Out) 구조**로 알려져 있습니다.
즉, 가장 먼저 큐에 들어온 항목이 가장 먼저 나가게 됩니다.

![](https://github.com/devKobe24/images/blob/main/images_awesomeo184_post_c1d73c47-1103-4c47-94cd-8563e85b6542_%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-10-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.25.31.png?raw=true)

🤔 **큐의 기본 연산**</br>
큐는 다음과 같은 기본적인 연산을 지원합니다.
- **Enqueue** : 항목을 큐의 뒤에 추가합니다.
- **Dequeue** : 가장 먼저 들어온 항목을 큐에서 제거하고 그 값을 반환합니다.
- **Peek/Front** : 큐에서 가장 먼저 들어온 항목을 제거하지 않고 그 값을 변환합니다.
- **IsEmpty** : 큐가 비어 있는지를 확인합니다.

> 📓 큐의 활용 분야
> 큐는 여러 분야에서 다양하게 사용됩니다.
> 예를 들어, 컴퓨터의 작업 스케줄링, 네트워크 트래픽 관리, 자료 처리 등에서 활용되고 있습니다.
> 큐는 배열 또는 연결 리스트로 구현할 수 있으며, 보다 복잡한 자료구조인 스택 두 개를 이용하여 구현할 수도 있습니다.

---

## 🧩 Queue의 시간 복잡도

**큐의 기본적인 연산들인 Enqueue(삽입), Dequeue(제거), Peek(가장 앞의 요소 확인), isEmpty(비어있는지 확인)는 모두 일반적으로 O(1)의 시간 복잡도를 가집니다.**

**이 말은, 이러한 연산들이 실행되는데 필요한 시간이 큐에 들어 있는 요소의 개수에 영향을 받지 않는다는 것을 의미합니다.**

예를 들어 Enqueue 연산은 항상 큐의 끝에 요소를 추가하기 때문에, 큐에 얼마나 많은 요소들이 있는지와 관계없이 이 연산을 수행하는데 필요한 시간은 일정합니다.

**단, 이러한 시간 복잡도는 큐가 적절하게 구현되었을 때만 유효합니다.**

예를 들어, 배열을 사용하여 큐를 구현할 경우, 배열의 크기를 늘려야 하는 상황에서는 Enqueue 연산의 시간 복잡도가 O(n)이 될 수 있습니다.(여기서 n은 큐의 크기 입니다.)

이 외에도, 큐의 전체 내용을 탐색하거나 정렬하는 등의 연산은 더 많은 시간이 필요할 수 있으며, 이 경우의 시간 복잡도는 큐의 크기에 따라 달라집니다.

---

## 🧩 List

🤔 **리스트(List)?**</br>
**리스트(List)는 컴퓨터 과학에서 가장 기본적인 자료구조 중 하나로, 데이터 항목들의 모음입니다.**

🤔 **리스트(List) 특징**</br>
**리스트의 각 항목은 다른 항목들과 순차적으로 연결되어 있습니다.**
**각 항목은 리스트 내의 위치(인덱스)에 따라 참조됩니다.**

🤔 **리스트(List) 종류와 설명**</br>
리스트는 다양한 종류가 있으며, 가장 일반적인 타입은 연결 리스트와 배열입니다.

1. **연결 리스트(Linked List)** : 각 요소가 다음 요소에 대한 참조와 그 요소의 데이터를 포함하는 **노드**로 이루어진 데이터 구조입니다. 노드들이 메모리 상의 어디에나 위치할 수 있기 때문에, 이 리스트의 크기는 동적으로 변할 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/221066355701C41E35.png?raw=true" width = 700>

---

2. **배열(Array)** : 각 요소가 메모리에서 연속적으로 배치된 데이터 구조입니다. 배열의 크기는 고정되어 있으며, 생성 후에는 변경할 수 없습니다.

![](https://github.com/devKobe24/images/blob/main/02_array.png?raw=true)

---

🤔 **리스트(List)의 기본적인 연산**</br>
1. **삽입(Insert)** : 리스트의 특정 위치에 항목을 추가합니다.
2. **삭제(Delete)** : 리스트의 특정 항목을 삭제합니다.
3. **검색(Search)** : 리스트 내의 특정 항목을 찾습니다.
4. **갱신(Update)** : 리스트의 특정 항목을 수정합니다.
5. **길이 확인(Size/Length)** : 리스트 내의 항목 수를 반환합니다.

---
🤔 **리스트(List)의 시간 복잡도**</br>

리스트의 시간 복잡도는 연산의 종류와 리스트의 종류(연결 리스트, 배열 등)에 따라 다릅니다.
일반적으로 배열은 인덱스를 통한 요소 접근이 빠르지만(일반적으로 O(1)), 삽입과 삭제가 느릴 수 있습니다.
반면 연결 리스트는 삽입과 삭제가 빠르지만(일반적으로 O(1)), 특정 요소에 접근하는데 느릴 수 있습니다(일반적으로 O(n)).

---

## 🧩 Linked List(연결 리스트) 

🤔 **연결 리스트(Linked List)?**</br>

연결 리스트(Linked List)는 컴퓨터 과학에서 사용되는 기본적인 자료 구조 중 하나입니다.
**연결 리스트는 노드(node)라는 요소들이 포인터(참조)를 통해 연결되어 있는 구조를 가집니다.**
**각 노드는 데이터와 다음 노드를 가리키는 포인터(참조)로 구성됩니다.**

---

🤔 **연결 리스트(Linked List)의 특징**</br>

1. **동적 크기** : 연결 리스트는 크기가 고정되지 않고, 노드를 추가하거나 제거함으로써 동적으로 크기를 변경할 수 있습니다.
2. **비연속 메모리 할당** : 연결 리스트의 노드들은 메모리의 어느 곳에나 위치할 수 있습니다. 배열과 달리 연속적인 메모리 할당이 필요하지 않습니다.

---

🤔 **연결 리스트(Linked List)의 연산**</br>

1. **삽입(Insertion)** : 특정 위치에 노드를 삽입할 수 있습니다. 일반적으로 이 연산은 O(1)의 시간 복잡도를 가지지만, 노드를 특정 위치에 삽입하려면 해당 위치를 찾는 데 O(n)의 시간이 걸릴 수 있습니다.
2. **삭제(Deletion)** : 특정 위치의 노드를 삭제할 수 있습니다. 마찬가지로, 이 연산은 O(1)의 시간 복잡도를 가지지만, 노드를 찾는데 O(n)의 시간이 필요할 수 있습니다.
3. **탐색(Search)** : 특정 값이나 노드를 찾는 데에는 O(n)의 시간이 걸립니다. 이는 모든 노드를 순차적으로 검사해야 하기 때문입니다.

---

🤔 **연결 리스트(Linked List)의 변형과 설명**</br>

연결 리스트에는 단일 연결 리스트(Singly Linked List), 이중 연결 리스트(Doubly Linked List), 원형 연결 리스트(Circular Linked List) 등 다양한 변형이 있습니다.

단일 연결 리스트는 각 노드가 다음 노드만 가리킵니다. 
이중 연결 리스트는 각 노드가 이전 노드와 다음 노드를 모두 가리킵니다. 
원형 연결 리스트는 리스트의 마지막 노트가 첫 번째 노드를 가리키는 형태로, 리스트의 끝과 시작이 연결되어 있습니다.
<img src = "https://github.com/devKobe24/images/blob/main/221066355701C41E35.png?raw=true" width = 500>
<img src = "https://github.com/devKobe24/images/blob/main/CircularLinkedListPhoto.png?raw=true" width = 500>

---
